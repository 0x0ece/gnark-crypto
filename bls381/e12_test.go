// Code generated by internal/tower DO NOT EDIT
package bls381

import (
	"fmt"
	"reflect"
	"testing"
)

type E12TestPoint struct {
	in  [2]E12
	out [17]E12
}

var E12TestPoints []E12TestPoint

// TODO this method is the same everywhere. move it someplace central and call it "compare"
func E12compare(t *testing.T, got, want interface{}) {
	if !reflect.DeepEqual(got, want) {
		t.Fatal("\nexpect:\t", want, "\ngot:\t", got)
	}
}

func E12check(t *testing.T, f func(*E12, *E12, *E12) *E12, m int) {

	if len(E12TestPoints) < 1 {
		t.Log("no tests to run")
	}

	for i := range E12TestPoints {
		var receiver E12
		var out *E12
		var inCopies [len(E12TestPoints[i].in)]E12

		for j := range inCopies {
			inCopies[j].Set(&E12TestPoints[i].in[j])
		}

		// receiver, return value both set to result
		out = f(&receiver, &inCopies[0], &inCopies[1])

		E12compare(t, receiver, E12TestPoints[i].out[m]) // receiver correct
		E12compare(t, *out, E12TestPoints[i].out[m])     // return value correct
		for j := range inCopies {
			E12compare(t, inCopies[j], E12TestPoints[i].in[j]) // inputs unchanged
		}

		// receiver == one of the inputs
		for j := range inCopies {
			out = f(&inCopies[j], &inCopies[0], &inCopies[1])

			E12compare(t, inCopies[j], E12TestPoints[i].out[m]) // receiver correct
			E12compare(t, *out, E12TestPoints[i].out[m])        // return value correct
			for k := range inCopies {
				if k == j {
					continue
				}
				E12compare(t, inCopies[k], E12TestPoints[i].in[k]) // other inputs unchanged
			}
			inCopies[j].Set(&E12TestPoints[i].in[j]) // reset input for next tests
		}
	}
}

//--------------------//
//     tests		  //
//--------------------//

func TestCycloSquare(t *testing.T) {
	t.Skip()
	var a E12
	a.C0.B0.A0.SetString("1125072297731382902998299617879606393499709029188003643946166382965379098202732821509561541450713115569207565047729")
	a.C0.B0.A1.SetString("357267673522920829364987037930948607675213838915560861452910819759875466909965828900241076435336951242792416960472")
	a.C0.B1.A0.SetString("1987735468309181410854523297998910368067402344245302433071674220984520853134212231520989377083661921684726636822203")
	a.C0.B1.A1.SetString("3078788936339241826019628074347117007612655788393653508620912675920884332954869997531075527318577230674279889727517")
	a.C0.B2.A0.SetString("606096396946834167020088181447512195646648624798244403036993381091258042638474265397393746530767190765251800095150")
	a.C0.B2.A1.SetString("765104595319501786306301970572308463780324552170891372013005158453958269421976154496670472558810291317440185682321")

	a.C1.B0.A0.SetString("532417150049868768803851413942598186479745157010957745052829772443704612986590037434859754860752903032079030649089")
	a.C1.B0.A1.SetString("3880522962080780495063608492282356300692158206629927988705015238873711065525995208687227900723361847434225437474555")
	a.C1.B1.A0.SetString("1062944682025931268139308150715375751207962784457829120070348027021962970941611739469506759735869607564192451518809")
	a.C1.B1.A1.SetString("2467093686626274960476841057070780908319363070636488881336872757940479107908242664519638623004531793926692899248971")
	a.C1.B2.A0.SetString("2385731102610501598810999573444339392927667778371372455029715066045750289692603646778961098121426397253068943202295")
	a.C1.B2.A1.SetString("803858520773611672426086895244279582330789619913718232935537265096633341857271101022263404527218888918607995760226")

	a.CyclotomicSquare(&a)

	fmt.Println(a.String())

}

func TestE12Add(t *testing.T) {
	E12check(t, (*E12).Add, 0)
}

func TestE12Sub(t *testing.T) {
	E12check(t, (*E12).Sub, 1)
}

func TestE12Mul(t *testing.T) {
	E12check(t, (*E12).Mul, 2)
}

func TestE12MulByV2NRInv(t *testing.T) {
	E12check(t, (*E12).MulByV2NRInvBinary, 6)
}

func TestE12MulByVWNRInv(t *testing.T) {
	E12check(t, (*E12).MulByVWNRInvBinary, 7)
}

func TestE12MulByWNRInv(t *testing.T) {
	E12check(t, (*E12).MulByWNRInvBinary, 8)
}

func TestE12Square(t *testing.T) {
	E12check(t, (*E12).SquareBinary, 9)
}

func TestE12Inverse(t *testing.T) {
	E12check(t, (*E12).InverseBinary, 10)
}

func TestE12Conjugate(t *testing.T) {
	E12check(t, (*E12).ConjugateBinary, 11)
}

func TestE12Frobenius(t *testing.T) {
	E12check(t, (*E12).FrobeniusBinary, 12)
}

func TestE12FrobeniusSquare(t *testing.T) {
	E12check(t, (*E12).FrobeniusSquareBinary, 13)
}

func TestE12FrobeniusCube(t *testing.T) {
	E12check(t, (*E12).FrobeniusCubeBinary, 14)
}

func TestE12Expt(t *testing.T) {
	E12check(t, (*E12).ExptBinary, 15)
}

func TestE12FinalExponentiation(t *testing.T) {
	E12check(t, (*E12).FinalExponentiationBinary, 16)
}

//--------------------//
//     benches		  //
//--------------------//

var E12BenchIn1, E12BenchIn2, E12BenchOut E12

func BenchmarkE12Add(b *testing.B) {
	for i := 0; i < b.N; i++ {
		E12BenchOut.Add(&E12BenchIn1, &E12BenchIn2)
	}
}

func BenchmarkE12Sub(b *testing.B) {
	for i := 0; i < b.N; i++ {
		E12BenchOut.Sub(&E12BenchIn1, &E12BenchIn2)
	}
}

func BenchmarkE12Mul(b *testing.B) {
	for i := 0; i < b.N; i++ {
		E12BenchOut.Mul(&E12BenchIn1, &E12BenchIn2)
	}
}

func BenchmarkE12MulByV2NRInv(b *testing.B) {
	for i := 0; i < b.N; i++ {
		E12BenchOut.MulByV2NRInvBinary(&E12BenchIn1, &E12BenchIn2)
	}
}

func BenchmarkE12MulByVWNRInv(b *testing.B) {
	for i := 0; i < b.N; i++ {
		E12BenchOut.MulByVWNRInvBinary(&E12BenchIn1, &E12BenchIn2)
	}
}

func BenchmarkE12MulByWNRInv(b *testing.B) {
	for i := 0; i < b.N; i++ {
		E12BenchOut.MulByWNRInvBinary(&E12BenchIn1, &E12BenchIn2)
	}
}

func BenchmarkE12Square(b *testing.B) {
	for i := 0; i < b.N; i++ {
		E12BenchOut.SquareBinary(&E12BenchIn1, &E12BenchIn2)
	}
}

func BenchmarkCycloSquare(b *testing.B) {
	var a E12
	a.SetRandom()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		a.CyclotomicSquare(&a)
	}
}

func BenchmarkE12Inverse(b *testing.B) {
	for i := 0; i < b.N; i++ {
		E12BenchOut.InverseBinary(&E12BenchIn1, &E12BenchIn2)
	}
}

func BenchmarkE12Conjugate(b *testing.B) {
	for i := 0; i < b.N; i++ {
		E12BenchOut.ConjugateBinary(&E12BenchIn1, &E12BenchIn2)
	}
}

func BenchmarkE12Frobenius(b *testing.B) {
	for i := 0; i < b.N; i++ {
		E12BenchOut.FrobeniusBinary(&E12BenchIn1, &E12BenchIn2)
	}
}

func BenchmarkE12FrobeniusSquare(b *testing.B) {
	for i := 0; i < b.N; i++ {
		E12BenchOut.FrobeniusSquareBinary(&E12BenchIn1, &E12BenchIn2)
	}
}

func BenchmarkE12FrobeniusCube(b *testing.B) {
	for i := 0; i < b.N; i++ {
		E12BenchOut.FrobeniusCubeBinary(&E12BenchIn1, &E12BenchIn2)
	}
}

func BenchmarkE12Expt(b *testing.B) {
	for i := 0; i < b.N; i++ {
		E12BenchOut.ExptBinary(&E12BenchIn1, &E12BenchIn2)
	}
}

func BenchmarkE12FinalExponentiation(b *testing.B) {
	for i := 0; i < b.N; i++ {
		E12BenchOut.FinalExponentiationBinary(&E12BenchIn1, &E12BenchIn2)
	}
}

//-------------------------------------//
// unary helpers for E12 methods
//-------------------------------------//

// SquareBinary a binary wrapper for Square
func (z *E12) SquareBinary(x, y *E12) *E12 {
	return z.Square(x)
}

// InverseBinary a binary wrapper for Inverse
func (z *E12) InverseBinary(x, y *E12) *E12 {
	return z.Inverse(x)
}

// ConjugateBinary a binary wrapper for Conjugate
func (z *E12) ConjugateBinary(x, y *E12) *E12 {
	return z.Conjugate(x)
}

// FrobeniusBinary a binary wrapper for Frobenius
func (z *E12) FrobeniusBinary(x, y *E12) *E12 {
	return z.Frobenius(x)
}

// FrobeniusSquareBinary a binary wrapper for FrobeniusSquare
func (z *E12) FrobeniusSquareBinary(x, y *E12) *E12 {
	return z.FrobeniusSquare(x)
}

// FrobeniusCubeBinary a binary wrapper for FrobeniusCube
func (z *E12) FrobeniusCubeBinary(x, y *E12) *E12 {
	return z.FrobeniusCube(x)
}

// FinalExponentiationBinary a binary wrapper for FinalExponentiation
func (z *E12) FinalExponentiationBinary(x, y *E12) *E12 {
	return z.FinalExponentiation(x)
}

//-------------------------------------//
// custom helpers for E12 methods
//-------------------------------------//

// ExptBinary a binary wrapper for Expt
func (z *E12) ExptBinary(x, y *E12) *E12 {
	z.Expt(x)

	// if tAbsVal is negative then need to undo the conjugation in order to match the test point
	z.Conjugate(z) // because tAbsVal is negative

	return z
}

// MulByV2NRInvBinary a binary wrapper for MulByV2NRInv
func (z *E12) MulByV2NRInvBinary(x, y *E12) *E12 {
	yCopy := y.C0.B2
	z.MulByV2NRInv(x, &yCopy)
	return z
}

// MulByVWNRInvBinary a binary wrapper for MulByVWNRInv
func (z *E12) MulByVWNRInvBinary(x, y *E12) *E12 {
	yCopy := y.C1.B1
	z.MulByVWNRInv(x, &yCopy)
	return z
}

// MulByWNRInvBinary a binary wrapper for MulByWNRInv
func (z *E12) MulByWNRInvBinary(x, y *E12) *E12 {
	yCopy := y.C1.B0
	z.MulByWNRInv(x, &yCopy)
	return z
}
