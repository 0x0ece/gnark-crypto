package generator

import (
	"math/big"
	"path/filepath"
	"strconv"
	"text/template"

	"github.com/consensys/bavard"
	goff "github.com/consensys/goff/cmd"
	"github.com/consensys/gurvy/internal/templates/fq12over6over2"
	"github.com/consensys/gurvy/internal/templates/pairing"
	"github.com/consensys/gurvy/internal/templates/point"
)

// CurveConfig describes parameters of the curve useful for the templates
type CurveConfig struct {
	CurveName string
	CoordType string
	PointName string
	RTorsion  string
	RBitLen   int
	FpModulus string
	OutputDir string
	GLV       bool
}

// GenerateBaseFields generates the base field fr and fp
func GenerateBaseFields(conf CurveConfig) error {
	if err := goff.GenerateFF("fr", "Element", conf.RTorsion, filepath.Join(conf.OutputDir, "fr"), false); err != nil {
		return err
	}
	if err := goff.GenerateFF("fp", "Element", conf.FpModulus, filepath.Join(conf.OutputDir, "fp"), false); err != nil {
		return err
	}
	return nil
}

// GenerateFq12over6over2 generates a tower 2->6->12 over fp
func GenerateFq12over6over2(conf CurveConfig) error {

	// fq2 base
	src := []string{
		fq12over6over2.Fq2Common,
	}

	bavardOpts := []func(*bavard.Bavard) error{
		bavard.Apache2("ConsenSys AG", 2020),
		bavard.Package(conf.CurveName),
		bavard.GeneratedBy("gurvy"),
	}
	pathSrc := filepath.Join(conf.OutputDir, "e2.go")

	if err := bavard.Generate(pathSrc, src, conf, bavardOpts...); err != nil {
		return err
	}

	{
		// fq2 assembly, generated by goff
		if err := goff.GenerateFF2(conf.CurveName, "E2", conf.FpModulus, conf.OutputDir); err != nil {
			return err
		}
	}

	{
		// fq2 fallback
		src := []string{
			fq12over6over2.Fq2FallBack,
		}

		bavardOpts := []func(*bavard.Bavard) error{
			bavard.Apache2("ConsenSys AG", 2020),
			bavard.Package(conf.CurveName),
			bavard.GeneratedBy("gurvy"),
			bavard.BuildTag("!amd64"),
		}
		pathSrc := filepath.Join(conf.OutputDir, "e2_fallback.go")

		if err := bavard.Generate(pathSrc, src, conf, bavardOpts...); err != nil {
			return err
		}

	}

	// fq2 tests
	src = []string{
		fq12over6over2.Fq2Tests,
	}
	pathSrc = filepath.Join(conf.OutputDir, "e2_test.go")
	if err := bavard.Generate(pathSrc, src, conf, bavardOpts...); err != nil {
		return err
	}

	// fq6 base
	src = []string{
		fq12over6over2.Fq6,
	}

	bavardOpts = []func(*bavard.Bavard) error{
		bavard.Apache2("ConsenSys AG", 2020),
		bavard.Package(conf.CurveName),
	}

	pathSrc = filepath.Join(conf.OutputDir, "e6.go")

	if err := bavard.Generate(pathSrc, src, conf, bavardOpts...); err != nil {
		return err
	}

	// fq6 tests
	src = []string{
		fq12over6over2.Fq6Tests,
	}
	pathSrc = filepath.Join(conf.OutputDir, "e6_test.go")
	if err := bavard.Generate(pathSrc, src, conf, bavardOpts...); err != nil {
		return err
	}

	// fq12 base
	src = []string{
		fq12over6over2.Fq12,
	}

	bavardOpts = []func(*bavard.Bavard) error{
		bavard.Apache2("ConsenSys AG", 2020),
		bavard.Package(conf.CurveName),
	}

	pathSrc = filepath.Join(conf.OutputDir, "e12.go")

	if err := bavard.Generate(pathSrc, src, conf, bavardOpts...); err != nil {
		return err
	}

	// fq12 tests
	src = []string{
		fq12over6over2.Fq12Tests,
	}
	pathSrc = filepath.Join(conf.OutputDir, "e12_test.go")
	if err := bavard.Generate(pathSrc, src, conf, bavardOpts...); err != nil {
		return err
	}

	return nil
}

// Template helpers (txt/template)
func helpers() template.FuncMap {
	// functions used in template
	return template.FuncMap{
		"divides": divides,
	}
}

// return true if c1 divides c2, that is, c2 % c1 == 0
func divides(c1, c2 interface{}) bool {
	switch cc1 := c1.(type) {
	case int:
		switch cc2 := c2.(type) {
		case int:
			return cc2%cc1 == 0
		case string:
			c2Int, err := strconv.Atoi(cc2)
			if err != nil {
				panic(err)
			}
			return c2Int%cc1 == 0
		}
	case string:
		c1Int, err := strconv.Atoi(cc1)
		if err != nil {
			panic(err)
		}
		switch cc2 := c2.(type) {
		case int:
			return cc2%c1Int == 0
		case string:
			c2Int, err := strconv.Atoi(cc2)
			if err != nil {
				panic(err)
			}
			return c2Int%c1Int == 0
		}
	}
	panic("unexpected type")
}

// GeneratePoint generates elliptic curve arithmetic
func GeneratePoint(conf CurveConfig) error {

	bavardOpts := []func(*bavard.Bavard) error{
		bavard.Apache2("ConsenSys AG", 2020),
		bavard.Package(conf.CurveName),
		bavard.GeneratedBy("gurvy"),
		bavard.Funcs(helpers()),
	}

	// point code
	src := []string{
		point.Point,
	}

	// bit len of R
	if conf.RBitLen == 0 {
		r, ok := new(big.Int).SetString(conf.RTorsion, 10)
		if !ok {
			panic("can't set r from RTorsion")
		}
		conf.RBitLen = r.BitLen()
	}

	pathSrc := filepath.Join(conf.OutputDir, conf.PointName+".go")
	if err := bavard.Generate(pathSrc, src, conf, bavardOpts...); err != nil {
		return err
	}

	// point test
	src = []string{
		point.PointTests,
	}

	pathSrc = filepath.Join(conf.OutputDir, conf.PointName+"_test.go")
	if err := bavard.Generate(pathSrc, src, conf, bavardOpts...); err != nil {
		return err
	}

	return nil
}

// GeneratePairing generates elliptic curve arithmetic
func GeneratePairing(conf CurveConfig) error {

	src := []string{
		pairing.PairingTests,
	}

	bavardOpts := []func(*bavard.Bavard) error{
		bavard.Apache2("ConsenSys AG", 2020),
		bavard.Package(conf.CurveName),
		bavard.GeneratedBy("gurvy"),
	}

	pathSrc := filepath.Join(conf.OutputDir, "pairing_test.go")

	if err := bavard.Generate(pathSrc, src, conf, bavardOpts...); err != nil {
		return err
	}

	return nil
}
