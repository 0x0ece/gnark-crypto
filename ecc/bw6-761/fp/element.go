// Copyright 2020 ConsenSys Software Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by consensys/gnark-crypto DO NOT EDIT

package fp

// /!\ WARNING /!\
// this code has not been audited and is provided as-is. In particular,
// there is no security guarantees such as constant time implementation
// or side-channel attack resistance
// /!\ WARNING /!\

import (
	"crypto/rand"
	"encoding/binary"
	"errors"
	"io"
	"math/big"
	"math/bits"
	"reflect"
	"strconv"
	"sync"
)

// Element represents a field element stored on 12 words (uint64)
// Element are assumed to be in Montgomery form in all methods
// field modulus q =
//
// 6891450384315732539396789682275657542479668912536150109513790160209623422243491736087683183289411687640864567753786613451161759120554247759349511699125301598951605099378508850372543631423596795951899700429969112842764913119068299
type Element [12]uint64

// Limbs number of 64 bits words needed to represent Element
const Limbs = 12

// Bits number bits needed to represent Element
const Bits = 761

// Bytes number bytes needed to represent Element
const Bytes = Limbs * 8

// field modulus stored as big.Int
var _modulus big.Int

// Modulus returns q as a big.Int
// q =
//
// 6891450384315732539396789682275657542479668912536150109513790160209623422243491736087683183289411687640864567753786613451161759120554247759349511699125301598951605099378508850372543631423596795951899700429969112842764913119068299
func Modulus() *big.Int {
	return new(big.Int).Set(&_modulus)
}

// q (modulus)
var qElement = Element{
	17626244516597989515,
	16614129118623039618,
	1588918198704579639,
	10998096788944562424,
	8204665564953313070,
	9694500593442880912,
	274362232328168196,
	8105254717682411801,
	5945444129596489281,
	13341377791855249032,
	15098257552581525310,
	81882988782276106,
}

// rSquare
var rSquare = Element{
	14305184132582319705,
	8868935336694416555,
	9196887162930508889,
	15486798265448570248,
	5402985275949444416,
	10893197322525159598,
	3204916688966998390,
	12417238192559061753,
	12426306557607898622,
	1305582522441154384,
	10311846026977660324,
	48736111365249031,
}

var bigIntPool = sync.Pool{
	New: func() interface{} {
		return new(big.Int)
	},
}

func init() {
	_modulus.SetString("6891450384315732539396789682275657542479668912536150109513790160209623422243491736087683183289411687640864567753786613451161759120554247759349511699125301598951605099378508850372543631423596795951899700429969112842764913119068299", 10)
}

// NewElement returns a new Element from a uint64 value
//
// it is equivalent to
// 		var v NewElement
// 		v.SetUint64(...)
func NewElement(v uint64) Element {
	z := Element{v}
	z.Mul(&z, &rSquare)
	return z
}

// SetUint64 z = v, sets z LSB to v (non-Montgomery form) and convert z to Montgomery form
func (z *Element) SetUint64(v uint64) *Element {
	*z = Element{v}
	return z.Mul(z, &rSquare) // z.ToMont()
}

// Set z = x
func (z *Element) Set(x *Element) *Element {
	z[0] = x[0]
	z[1] = x[1]
	z[2] = x[2]
	z[3] = x[3]
	z[4] = x[4]
	z[5] = x[5]
	z[6] = x[6]
	z[7] = x[7]
	z[8] = x[8]
	z[9] = x[9]
	z[10] = x[10]
	z[11] = x[11]
	return z
}

// SetInterface converts provided interface into Element
// returns an error if provided type is not supported
// supported types: Element, *Element, uint64, int, string (interpreted as base10 integer),
// *big.Int, big.Int, []byte
func (z *Element) SetInterface(i1 interface{}) (*Element, error) {
	switch c1 := i1.(type) {
	case Element:
		return z.Set(&c1), nil
	case *Element:
		return z.Set(c1), nil
	case uint64:
		return z.SetUint64(c1), nil
	case int:
		return z.SetString(strconv.Itoa(c1)), nil
	case string:
		return z.SetString(c1), nil
	case *big.Int:
		return z.SetBigInt(c1), nil
	case big.Int:
		return z.SetBigInt(&c1), nil
	case []byte:
		return z.SetBytes(c1), nil
	default:
		return nil, errors.New("can't set fp.Element from type " + reflect.TypeOf(i1).String())
	}
}

// SetZero z = 0
func (z *Element) SetZero() *Element {
	z[0] = 0
	z[1] = 0
	z[2] = 0
	z[3] = 0
	z[4] = 0
	z[5] = 0
	z[6] = 0
	z[7] = 0
	z[8] = 0
	z[9] = 0
	z[10] = 0
	z[11] = 0
	return z
}

// SetOne z = 1 (in Montgomery form)
func (z *Element) SetOne() *Element {
	z[0] = 144959613005956565
	z[1] = 6509995272855063783
	z[2] = 11428286765660613342
	z[3] = 15738672438262922740
	z[4] = 17071399330169272331
	z[5] = 13899911246788437003
	z[6] = 12055474021000362245
	z[7] = 2545351818702954755
	z[8] = 8887388221587179644
	z[9] = 5009280847225881135
	z[10] = 15539704305423854047
	z[11] = 23071597697427581
	return z
}

// Div z = x*y^-1 mod q
func (z *Element) Div(x, y *Element) *Element {
	var yInv Element
	yInv.Inverse(y)
	z.Mul(x, &yInv)
	return z
}

// Bit returns the i'th bit, with lsb == bit 0.
// It is the responsability of the caller to convert from Montgomery to Regular form if needed
func (z *Element) Bit(i uint64) uint64 {
	j := i / 64
	if j >= 12 {
		return 0
	}
	return uint64(z[j] >> (i % 64) & 1)
}

// Equal returns z == x
func (z *Element) Equal(x *Element) bool {
	return (z[11] == x[11]) && (z[10] == x[10]) && (z[9] == x[9]) && (z[8] == x[8]) && (z[7] == x[7]) && (z[6] == x[6]) && (z[5] == x[5]) && (z[4] == x[4]) && (z[3] == x[3]) && (z[2] == x[2]) && (z[1] == x[1]) && (z[0] == x[0])
}

// IsZero returns z == 0
func (z *Element) IsZero() bool {
	return (z[11] | z[10] | z[9] | z[8] | z[7] | z[6] | z[5] | z[4] | z[3] | z[2] | z[1] | z[0]) == 0
}

// IsUint64 returns true if z[0] >= 0 and all other words are 0
func (z *Element) IsUint64() bool {
	return (z[11] | z[10] | z[9] | z[8] | z[7] | z[6] | z[5] | z[4] | z[3] | z[2] | z[1]) == 0
}

// Cmp compares (lexicographic order) z and x and returns:
//
//   -1 if z <  x
//    0 if z == x
//   +1 if z >  x
//
func (z *Element) Cmp(x *Element) int {
	_z := *z
	_x := *x
	_z.FromMont()
	_x.FromMont()
	if _z[11] > _x[11] {
		return 1
	} else if _z[11] < _x[11] {
		return -1
	}
	if _z[10] > _x[10] {
		return 1
	} else if _z[10] < _x[10] {
		return -1
	}
	if _z[9] > _x[9] {
		return 1
	} else if _z[9] < _x[9] {
		return -1
	}
	if _z[8] > _x[8] {
		return 1
	} else if _z[8] < _x[8] {
		return -1
	}
	if _z[7] > _x[7] {
		return 1
	} else if _z[7] < _x[7] {
		return -1
	}
	if _z[6] > _x[6] {
		return 1
	} else if _z[6] < _x[6] {
		return -1
	}
	if _z[5] > _x[5] {
		return 1
	} else if _z[5] < _x[5] {
		return -1
	}
	if _z[4] > _x[4] {
		return 1
	} else if _z[4] < _x[4] {
		return -1
	}
	if _z[3] > _x[3] {
		return 1
	} else if _z[3] < _x[3] {
		return -1
	}
	if _z[2] > _x[2] {
		return 1
	} else if _z[2] < _x[2] {
		return -1
	}
	if _z[1] > _x[1] {
		return 1
	} else if _z[1] < _x[1] {
		return -1
	}
	if _z[0] > _x[0] {
		return 1
	} else if _z[0] < _x[0] {
		return -1
	}
	return 0
}

// LexicographicallyLargest returns true if this element is strictly lexicographically
// larger than its negation, false otherwise
func (z *Element) LexicographicallyLargest() bool {
	// adapted from github.com/zkcrypto/bls12_381
	// we check if the element is larger than (q-1) / 2
	// if z - (((q -1) / 2) + 1) have no underflow, then z > (q-1) / 2

	_z := *z
	_z.FromMont()

	var b uint64
	_, b = bits.Sub64(_z[0], 8813122258298994758, 0)
	_, b = bits.Sub64(_z[1], 17530436596166295617, b)
	_, b = bits.Sub64(_z[2], 794459099352289819, b)
	_, b = bits.Sub64(_z[3], 5499048394472281212, b)
	_, b = bits.Sub64(_z[4], 4102332782476656535, b)
	_, b = bits.Sub64(_z[5], 4847250296721440456, b)
	_, b = bits.Sub64(_z[6], 9360553153018859906, b)
	_, b = bits.Sub64(_z[7], 13275999395695981708, b)
	_, b = bits.Sub64(_z[8], 2972722064798244640, b)
	_, b = bits.Sub64(_z[9], 6670688895927624516, b)
	_, b = bits.Sub64(_z[10], 7549128776290762655, b)
	_, b = bits.Sub64(_z[11], 40941494391138053, b)

	return b == 0
}

// SetRandom sets z to a random element < q
func (z *Element) SetRandom() (*Element, error) {
	var bytes [96]byte
	if _, err := io.ReadFull(rand.Reader, bytes[:]); err != nil {
		return nil, err
	}
	z[0] = binary.BigEndian.Uint64(bytes[0:8])
	z[1] = binary.BigEndian.Uint64(bytes[8:16])
	z[2] = binary.BigEndian.Uint64(bytes[16:24])
	z[3] = binary.BigEndian.Uint64(bytes[24:32])
	z[4] = binary.BigEndian.Uint64(bytes[32:40])
	z[5] = binary.BigEndian.Uint64(bytes[40:48])
	z[6] = binary.BigEndian.Uint64(bytes[48:56])
	z[7] = binary.BigEndian.Uint64(bytes[56:64])
	z[8] = binary.BigEndian.Uint64(bytes[64:72])
	z[9] = binary.BigEndian.Uint64(bytes[72:80])
	z[10] = binary.BigEndian.Uint64(bytes[80:88])
	z[11] = binary.BigEndian.Uint64(bytes[88:96])
	z[11] %= 81882988782276106

	// if z > q --> z -= q
	// note: this is NOT constant time
	if !(z[11] < 81882988782276106 || (z[11] == 81882988782276106 && (z[10] < 15098257552581525310 || (z[10] == 15098257552581525310 && (z[9] < 13341377791855249032 || (z[9] == 13341377791855249032 && (z[8] < 5945444129596489281 || (z[8] == 5945444129596489281 && (z[7] < 8105254717682411801 || (z[7] == 8105254717682411801 && (z[6] < 274362232328168196 || (z[6] == 274362232328168196 && (z[5] < 9694500593442880912 || (z[5] == 9694500593442880912 && (z[4] < 8204665564953313070 || (z[4] == 8204665564953313070 && (z[3] < 10998096788944562424 || (z[3] == 10998096788944562424 && (z[2] < 1588918198704579639 || (z[2] == 1588918198704579639 && (z[1] < 16614129118623039618 || (z[1] == 16614129118623039618 && (z[0] < 17626244516597989515))))))))))))))))))))))) {
		var b uint64
		z[0], b = bits.Sub64(z[0], 17626244516597989515, 0)
		z[1], b = bits.Sub64(z[1], 16614129118623039618, b)
		z[2], b = bits.Sub64(z[2], 1588918198704579639, b)
		z[3], b = bits.Sub64(z[3], 10998096788944562424, b)
		z[4], b = bits.Sub64(z[4], 8204665564953313070, b)
		z[5], b = bits.Sub64(z[5], 9694500593442880912, b)
		z[6], b = bits.Sub64(z[6], 274362232328168196, b)
		z[7], b = bits.Sub64(z[7], 8105254717682411801, b)
		z[8], b = bits.Sub64(z[8], 5945444129596489281, b)
		z[9], b = bits.Sub64(z[9], 13341377791855249032, b)
		z[10], b = bits.Sub64(z[10], 15098257552581525310, b)
		z[11], _ = bits.Sub64(z[11], 81882988782276106, b)
	}

	return z, nil
}

// One returns 1 (in montgommery form)
func One() Element {
	var one Element
	one.SetOne()
	return one
}

// Halve sets z to z / 2 (mod p)
func (z *Element) Halve() {
	if z[0]&1 == 1 {
		var carry uint64

		// z = z + q
		z[0], carry = bits.Add64(z[0], 17626244516597989515, 0)
		z[1], carry = bits.Add64(z[1], 16614129118623039618, carry)
		z[2], carry = bits.Add64(z[2], 1588918198704579639, carry)
		z[3], carry = bits.Add64(z[3], 10998096788944562424, carry)
		z[4], carry = bits.Add64(z[4], 8204665564953313070, carry)
		z[5], carry = bits.Add64(z[5], 9694500593442880912, carry)
		z[6], carry = bits.Add64(z[6], 274362232328168196, carry)
		z[7], carry = bits.Add64(z[7], 8105254717682411801, carry)
		z[8], carry = bits.Add64(z[8], 5945444129596489281, carry)
		z[9], carry = bits.Add64(z[9], 13341377791855249032, carry)
		z[10], carry = bits.Add64(z[10], 15098257552581525310, carry)
		z[11], _ = bits.Add64(z[11], 81882988782276106, carry)

	}

	// z = z >> 1

	z[0] = z[0]>>1 | z[1]<<63
	z[1] = z[1]>>1 | z[2]<<63
	z[2] = z[2]>>1 | z[3]<<63
	z[3] = z[3]>>1 | z[4]<<63
	z[4] = z[4]>>1 | z[5]<<63
	z[5] = z[5]>>1 | z[6]<<63
	z[6] = z[6]>>1 | z[7]<<63
	z[7] = z[7]>>1 | z[8]<<63
	z[8] = z[8]>>1 | z[9]<<63
	z[9] = z[9]>>1 | z[10]<<63
	z[10] = z[10]>>1 | z[11]<<63
	z[11] >>= 1

}

// API with assembly impl

// Mul z = x * y mod q
// see https://hackmd.io/@zkteam/modular_multiplication
func (z *Element) Mul(x, y *Element) *Element {
	mul(z, x, y)
	return z
}

// Square z = x * x mod q
// see https://hackmd.io/@zkteam/modular_multiplication
func (z *Element) Square(x *Element) *Element {
	mul(z, x, x)
	return z
}

// FromMont converts z in place (i.e. mutates) from Montgomery to regular representation
// sets and returns z = z * 1
func (z *Element) FromMont() *Element {
	fromMont(z)
	return z
}

// Add z = x + y mod q
func (z *Element) Add(x, y *Element) *Element {
	add(z, x, y)
	return z
}

// Double z = x + x mod q, aka Lsh 1
func (z *Element) Double(x *Element) *Element {
	double(z, x)
	return z
}

// Sub  z = x - y mod q
func (z *Element) Sub(x, y *Element) *Element {
	sub(z, x, y)
	return z
}

// Neg z = q - x
func (z *Element) Neg(x *Element) *Element {
	neg(z, x)
	return z
}

// Generic (no ADX instructions, no AMD64) versions of multiplication and squaring algorithms

func _mulGeneric(z, x, y *Element) {

	var t [12]uint64
	var c [3]uint64
	{
		// round 0
		v := x[0]
		c[1], c[0] = bits.Mul64(v, y[0])
		m := c[0] * 744663313386281181
		c[2] = madd0(m, 17626244516597989515, c[0])
		c[1], c[0] = madd1(v, y[1], c[1])
		c[2], t[0] = madd2(m, 16614129118623039618, c[2], c[0])
		c[1], c[0] = madd1(v, y[2], c[1])
		c[2], t[1] = madd2(m, 1588918198704579639, c[2], c[0])
		c[1], c[0] = madd1(v, y[3], c[1])
		c[2], t[2] = madd2(m, 10998096788944562424, c[2], c[0])
		c[1], c[0] = madd1(v, y[4], c[1])
		c[2], t[3] = madd2(m, 8204665564953313070, c[2], c[0])
		c[1], c[0] = madd1(v, y[5], c[1])
		c[2], t[4] = madd2(m, 9694500593442880912, c[2], c[0])
		c[1], c[0] = madd1(v, y[6], c[1])
		c[2], t[5] = madd2(m, 274362232328168196, c[2], c[0])
		c[1], c[0] = madd1(v, y[7], c[1])
		c[2], t[6] = madd2(m, 8105254717682411801, c[2], c[0])
		c[1], c[0] = madd1(v, y[8], c[1])
		c[2], t[7] = madd2(m, 5945444129596489281, c[2], c[0])
		c[1], c[0] = madd1(v, y[9], c[1])
		c[2], t[8] = madd2(m, 13341377791855249032, c[2], c[0])
		c[1], c[0] = madd1(v, y[10], c[1])
		c[2], t[9] = madd2(m, 15098257552581525310, c[2], c[0])
		c[1], c[0] = madd1(v, y[11], c[1])
		t[11], t[10] = madd3(m, 81882988782276106, c[0], c[2], c[1])
	}
	{
		// round 1
		v := x[1]
		c[1], c[0] = madd1(v, y[0], t[0])
		m := c[0] * 744663313386281181
		c[2] = madd0(m, 17626244516597989515, c[0])
		c[1], c[0] = madd2(v, y[1], c[1], t[1])
		c[2], t[0] = madd2(m, 16614129118623039618, c[2], c[0])
		c[1], c[0] = madd2(v, y[2], c[1], t[2])
		c[2], t[1] = madd2(m, 1588918198704579639, c[2], c[0])
		c[1], c[0] = madd2(v, y[3], c[1], t[3])
		c[2], t[2] = madd2(m, 10998096788944562424, c[2], c[0])
		c[1], c[0] = madd2(v, y[4], c[1], t[4])
		c[2], t[3] = madd2(m, 8204665564953313070, c[2], c[0])
		c[1], c[0] = madd2(v, y[5], c[1], t[5])
		c[2], t[4] = madd2(m, 9694500593442880912, c[2], c[0])
		c[1], c[0] = madd2(v, y[6], c[1], t[6])
		c[2], t[5] = madd2(m, 274362232328168196, c[2], c[0])
		c[1], c[0] = madd2(v, y[7], c[1], t[7])
		c[2], t[6] = madd2(m, 8105254717682411801, c[2], c[0])
		c[1], c[0] = madd2(v, y[8], c[1], t[8])
		c[2], t[7] = madd2(m, 5945444129596489281, c[2], c[0])
		c[1], c[0] = madd2(v, y[9], c[1], t[9])
		c[2], t[8] = madd2(m, 13341377791855249032, c[2], c[0])
		c[1], c[0] = madd2(v, y[10], c[1], t[10])
		c[2], t[9] = madd2(m, 15098257552581525310, c[2], c[0])
		c[1], c[0] = madd2(v, y[11], c[1], t[11])
		t[11], t[10] = madd3(m, 81882988782276106, c[0], c[2], c[1])
	}
	{
		// round 2
		v := x[2]
		c[1], c[0] = madd1(v, y[0], t[0])
		m := c[0] * 744663313386281181
		c[2] = madd0(m, 17626244516597989515, c[0])
		c[1], c[0] = madd2(v, y[1], c[1], t[1])
		c[2], t[0] = madd2(m, 16614129118623039618, c[2], c[0])
		c[1], c[0] = madd2(v, y[2], c[1], t[2])
		c[2], t[1] = madd2(m, 1588918198704579639, c[2], c[0])
		c[1], c[0] = madd2(v, y[3], c[1], t[3])
		c[2], t[2] = madd2(m, 10998096788944562424, c[2], c[0])
		c[1], c[0] = madd2(v, y[4], c[1], t[4])
		c[2], t[3] = madd2(m, 8204665564953313070, c[2], c[0])
		c[1], c[0] = madd2(v, y[5], c[1], t[5])
		c[2], t[4] = madd2(m, 9694500593442880912, c[2], c[0])
		c[1], c[0] = madd2(v, y[6], c[1], t[6])
		c[2], t[5] = madd2(m, 274362232328168196, c[2], c[0])
		c[1], c[0] = madd2(v, y[7], c[1], t[7])
		c[2], t[6] = madd2(m, 8105254717682411801, c[2], c[0])
		c[1], c[0] = madd2(v, y[8], c[1], t[8])
		c[2], t[7] = madd2(m, 5945444129596489281, c[2], c[0])
		c[1], c[0] = madd2(v, y[9], c[1], t[9])
		c[2], t[8] = madd2(m, 13341377791855249032, c[2], c[0])
		c[1], c[0] = madd2(v, y[10], c[1], t[10])
		c[2], t[9] = madd2(m, 15098257552581525310, c[2], c[0])
		c[1], c[0] = madd2(v, y[11], c[1], t[11])
		t[11], t[10] = madd3(m, 81882988782276106, c[0], c[2], c[1])
	}
	{
		// round 3
		v := x[3]
		c[1], c[0] = madd1(v, y[0], t[0])
		m := c[0] * 744663313386281181
		c[2] = madd0(m, 17626244516597989515, c[0])
		c[1], c[0] = madd2(v, y[1], c[1], t[1])
		c[2], t[0] = madd2(m, 16614129118623039618, c[2], c[0])
		c[1], c[0] = madd2(v, y[2], c[1], t[2])
		c[2], t[1] = madd2(m, 1588918198704579639, c[2], c[0])
		c[1], c[0] = madd2(v, y[3], c[1], t[3])
		c[2], t[2] = madd2(m, 10998096788944562424, c[2], c[0])
		c[1], c[0] = madd2(v, y[4], c[1], t[4])
		c[2], t[3] = madd2(m, 8204665564953313070, c[2], c[0])
		c[1], c[0] = madd2(v, y[5], c[1], t[5])
		c[2], t[4] = madd2(m, 9694500593442880912, c[2], c[0])
		c[1], c[0] = madd2(v, y[6], c[1], t[6])
		c[2], t[5] = madd2(m, 274362232328168196, c[2], c[0])
		c[1], c[0] = madd2(v, y[7], c[1], t[7])
		c[2], t[6] = madd2(m, 8105254717682411801, c[2], c[0])
		c[1], c[0] = madd2(v, y[8], c[1], t[8])
		c[2], t[7] = madd2(m, 5945444129596489281, c[2], c[0])
		c[1], c[0] = madd2(v, y[9], c[1], t[9])
		c[2], t[8] = madd2(m, 13341377791855249032, c[2], c[0])
		c[1], c[0] = madd2(v, y[10], c[1], t[10])
		c[2], t[9] = madd2(m, 15098257552581525310, c[2], c[0])
		c[1], c[0] = madd2(v, y[11], c[1], t[11])
		t[11], t[10] = madd3(m, 81882988782276106, c[0], c[2], c[1])
	}
	{
		// round 4
		v := x[4]
		c[1], c[0] = madd1(v, y[0], t[0])
		m := c[0] * 744663313386281181
		c[2] = madd0(m, 17626244516597989515, c[0])
		c[1], c[0] = madd2(v, y[1], c[1], t[1])
		c[2], t[0] = madd2(m, 16614129118623039618, c[2], c[0])
		c[1], c[0] = madd2(v, y[2], c[1], t[2])
		c[2], t[1] = madd2(m, 1588918198704579639, c[2], c[0])
		c[1], c[0] = madd2(v, y[3], c[1], t[3])
		c[2], t[2] = madd2(m, 10998096788944562424, c[2], c[0])
		c[1], c[0] = madd2(v, y[4], c[1], t[4])
		c[2], t[3] = madd2(m, 8204665564953313070, c[2], c[0])
		c[1], c[0] = madd2(v, y[5], c[1], t[5])
		c[2], t[4] = madd2(m, 9694500593442880912, c[2], c[0])
		c[1], c[0] = madd2(v, y[6], c[1], t[6])
		c[2], t[5] = madd2(m, 274362232328168196, c[2], c[0])
		c[1], c[0] = madd2(v, y[7], c[1], t[7])
		c[2], t[6] = madd2(m, 8105254717682411801, c[2], c[0])
		c[1], c[0] = madd2(v, y[8], c[1], t[8])
		c[2], t[7] = madd2(m, 5945444129596489281, c[2], c[0])
		c[1], c[0] = madd2(v, y[9], c[1], t[9])
		c[2], t[8] = madd2(m, 13341377791855249032, c[2], c[0])
		c[1], c[0] = madd2(v, y[10], c[1], t[10])
		c[2], t[9] = madd2(m, 15098257552581525310, c[2], c[0])
		c[1], c[0] = madd2(v, y[11], c[1], t[11])
		t[11], t[10] = madd3(m, 81882988782276106, c[0], c[2], c[1])
	}
	{
		// round 5
		v := x[5]
		c[1], c[0] = madd1(v, y[0], t[0])
		m := c[0] * 744663313386281181
		c[2] = madd0(m, 17626244516597989515, c[0])
		c[1], c[0] = madd2(v, y[1], c[1], t[1])
		c[2], t[0] = madd2(m, 16614129118623039618, c[2], c[0])
		c[1], c[0] = madd2(v, y[2], c[1], t[2])
		c[2], t[1] = madd2(m, 1588918198704579639, c[2], c[0])
		c[1], c[0] = madd2(v, y[3], c[1], t[3])
		c[2], t[2] = madd2(m, 10998096788944562424, c[2], c[0])
		c[1], c[0] = madd2(v, y[4], c[1], t[4])
		c[2], t[3] = madd2(m, 8204665564953313070, c[2], c[0])
		c[1], c[0] = madd2(v, y[5], c[1], t[5])
		c[2], t[4] = madd2(m, 9694500593442880912, c[2], c[0])
		c[1], c[0] = madd2(v, y[6], c[1], t[6])
		c[2], t[5] = madd2(m, 274362232328168196, c[2], c[0])
		c[1], c[0] = madd2(v, y[7], c[1], t[7])
		c[2], t[6] = madd2(m, 8105254717682411801, c[2], c[0])
		c[1], c[0] = madd2(v, y[8], c[1], t[8])
		c[2], t[7] = madd2(m, 5945444129596489281, c[2], c[0])
		c[1], c[0] = madd2(v, y[9], c[1], t[9])
		c[2], t[8] = madd2(m, 13341377791855249032, c[2], c[0])
		c[1], c[0] = madd2(v, y[10], c[1], t[10])
		c[2], t[9] = madd2(m, 15098257552581525310, c[2], c[0])
		c[1], c[0] = madd2(v, y[11], c[1], t[11])
		t[11], t[10] = madd3(m, 81882988782276106, c[0], c[2], c[1])
	}
	{
		// round 6
		v := x[6]
		c[1], c[0] = madd1(v, y[0], t[0])
		m := c[0] * 744663313386281181
		c[2] = madd0(m, 17626244516597989515, c[0])
		c[1], c[0] = madd2(v, y[1], c[1], t[1])
		c[2], t[0] = madd2(m, 16614129118623039618, c[2], c[0])
		c[1], c[0] = madd2(v, y[2], c[1], t[2])
		c[2], t[1] = madd2(m, 1588918198704579639, c[2], c[0])
		c[1], c[0] = madd2(v, y[3], c[1], t[3])
		c[2], t[2] = madd2(m, 10998096788944562424, c[2], c[0])
		c[1], c[0] = madd2(v, y[4], c[1], t[4])
		c[2], t[3] = madd2(m, 8204665564953313070, c[2], c[0])
		c[1], c[0] = madd2(v, y[5], c[1], t[5])
		c[2], t[4] = madd2(m, 9694500593442880912, c[2], c[0])
		c[1], c[0] = madd2(v, y[6], c[1], t[6])
		c[2], t[5] = madd2(m, 274362232328168196, c[2], c[0])
		c[1], c[0] = madd2(v, y[7], c[1], t[7])
		c[2], t[6] = madd2(m, 8105254717682411801, c[2], c[0])
		c[1], c[0] = madd2(v, y[8], c[1], t[8])
		c[2], t[7] = madd2(m, 5945444129596489281, c[2], c[0])
		c[1], c[0] = madd2(v, y[9], c[1], t[9])
		c[2], t[8] = madd2(m, 13341377791855249032, c[2], c[0])
		c[1], c[0] = madd2(v, y[10], c[1], t[10])
		c[2], t[9] = madd2(m, 15098257552581525310, c[2], c[0])
		c[1], c[0] = madd2(v, y[11], c[1], t[11])
		t[11], t[10] = madd3(m, 81882988782276106, c[0], c[2], c[1])
	}
	{
		// round 7
		v := x[7]
		c[1], c[0] = madd1(v, y[0], t[0])
		m := c[0] * 744663313386281181
		c[2] = madd0(m, 17626244516597989515, c[0])
		c[1], c[0] = madd2(v, y[1], c[1], t[1])
		c[2], t[0] = madd2(m, 16614129118623039618, c[2], c[0])
		c[1], c[0] = madd2(v, y[2], c[1], t[2])
		c[2], t[1] = madd2(m, 1588918198704579639, c[2], c[0])
		c[1], c[0] = madd2(v, y[3], c[1], t[3])
		c[2], t[2] = madd2(m, 10998096788944562424, c[2], c[0])
		c[1], c[0] = madd2(v, y[4], c[1], t[4])
		c[2], t[3] = madd2(m, 8204665564953313070, c[2], c[0])
		c[1], c[0] = madd2(v, y[5], c[1], t[5])
		c[2], t[4] = madd2(m, 9694500593442880912, c[2], c[0])
		c[1], c[0] = madd2(v, y[6], c[1], t[6])
		c[2], t[5] = madd2(m, 274362232328168196, c[2], c[0])
		c[1], c[0] = madd2(v, y[7], c[1], t[7])
		c[2], t[6] = madd2(m, 8105254717682411801, c[2], c[0])
		c[1], c[0] = madd2(v, y[8], c[1], t[8])
		c[2], t[7] = madd2(m, 5945444129596489281, c[2], c[0])
		c[1], c[0] = madd2(v, y[9], c[1], t[9])
		c[2], t[8] = madd2(m, 13341377791855249032, c[2], c[0])
		c[1], c[0] = madd2(v, y[10], c[1], t[10])
		c[2], t[9] = madd2(m, 15098257552581525310, c[2], c[0])
		c[1], c[0] = madd2(v, y[11], c[1], t[11])
		t[11], t[10] = madd3(m, 81882988782276106, c[0], c[2], c[1])
	}
	{
		// round 8
		v := x[8]
		c[1], c[0] = madd1(v, y[0], t[0])
		m := c[0] * 744663313386281181
		c[2] = madd0(m, 17626244516597989515, c[0])
		c[1], c[0] = madd2(v, y[1], c[1], t[1])
		c[2], t[0] = madd2(m, 16614129118623039618, c[2], c[0])
		c[1], c[0] = madd2(v, y[2], c[1], t[2])
		c[2], t[1] = madd2(m, 1588918198704579639, c[2], c[0])
		c[1], c[0] = madd2(v, y[3], c[1], t[3])
		c[2], t[2] = madd2(m, 10998096788944562424, c[2], c[0])
		c[1], c[0] = madd2(v, y[4], c[1], t[4])
		c[2], t[3] = madd2(m, 8204665564953313070, c[2], c[0])
		c[1], c[0] = madd2(v, y[5], c[1], t[5])
		c[2], t[4] = madd2(m, 9694500593442880912, c[2], c[0])
		c[1], c[0] = madd2(v, y[6], c[1], t[6])
		c[2], t[5] = madd2(m, 274362232328168196, c[2], c[0])
		c[1], c[0] = madd2(v, y[7], c[1], t[7])
		c[2], t[6] = madd2(m, 8105254717682411801, c[2], c[0])
		c[1], c[0] = madd2(v, y[8], c[1], t[8])
		c[2], t[7] = madd2(m, 5945444129596489281, c[2], c[0])
		c[1], c[0] = madd2(v, y[9], c[1], t[9])
		c[2], t[8] = madd2(m, 13341377791855249032, c[2], c[0])
		c[1], c[0] = madd2(v, y[10], c[1], t[10])
		c[2], t[9] = madd2(m, 15098257552581525310, c[2], c[0])
		c[1], c[0] = madd2(v, y[11], c[1], t[11])
		t[11], t[10] = madd3(m, 81882988782276106, c[0], c[2], c[1])
	}
	{
		// round 9
		v := x[9]
		c[1], c[0] = madd1(v, y[0], t[0])
		m := c[0] * 744663313386281181
		c[2] = madd0(m, 17626244516597989515, c[0])
		c[1], c[0] = madd2(v, y[1], c[1], t[1])
		c[2], t[0] = madd2(m, 16614129118623039618, c[2], c[0])
		c[1], c[0] = madd2(v, y[2], c[1], t[2])
		c[2], t[1] = madd2(m, 1588918198704579639, c[2], c[0])
		c[1], c[0] = madd2(v, y[3], c[1], t[3])
		c[2], t[2] = madd2(m, 10998096788944562424, c[2], c[0])
		c[1], c[0] = madd2(v, y[4], c[1], t[4])
		c[2], t[3] = madd2(m, 8204665564953313070, c[2], c[0])
		c[1], c[0] = madd2(v, y[5], c[1], t[5])
		c[2], t[4] = madd2(m, 9694500593442880912, c[2], c[0])
		c[1], c[0] = madd2(v, y[6], c[1], t[6])
		c[2], t[5] = madd2(m, 274362232328168196, c[2], c[0])
		c[1], c[0] = madd2(v, y[7], c[1], t[7])
		c[2], t[6] = madd2(m, 8105254717682411801, c[2], c[0])
		c[1], c[0] = madd2(v, y[8], c[1], t[8])
		c[2], t[7] = madd2(m, 5945444129596489281, c[2], c[0])
		c[1], c[0] = madd2(v, y[9], c[1], t[9])
		c[2], t[8] = madd2(m, 13341377791855249032, c[2], c[0])
		c[1], c[0] = madd2(v, y[10], c[1], t[10])
		c[2], t[9] = madd2(m, 15098257552581525310, c[2], c[0])
		c[1], c[0] = madd2(v, y[11], c[1], t[11])
		t[11], t[10] = madd3(m, 81882988782276106, c[0], c[2], c[1])
	}
	{
		// round 10
		v := x[10]
		c[1], c[0] = madd1(v, y[0], t[0])
		m := c[0] * 744663313386281181
		c[2] = madd0(m, 17626244516597989515, c[0])
		c[1], c[0] = madd2(v, y[1], c[1], t[1])
		c[2], t[0] = madd2(m, 16614129118623039618, c[2], c[0])
		c[1], c[0] = madd2(v, y[2], c[1], t[2])
		c[2], t[1] = madd2(m, 1588918198704579639, c[2], c[0])
		c[1], c[0] = madd2(v, y[3], c[1], t[3])
		c[2], t[2] = madd2(m, 10998096788944562424, c[2], c[0])
		c[1], c[0] = madd2(v, y[4], c[1], t[4])
		c[2], t[3] = madd2(m, 8204665564953313070, c[2], c[0])
		c[1], c[0] = madd2(v, y[5], c[1], t[5])
		c[2], t[4] = madd2(m, 9694500593442880912, c[2], c[0])
		c[1], c[0] = madd2(v, y[6], c[1], t[6])
		c[2], t[5] = madd2(m, 274362232328168196, c[2], c[0])
		c[1], c[0] = madd2(v, y[7], c[1], t[7])
		c[2], t[6] = madd2(m, 8105254717682411801, c[2], c[0])
		c[1], c[0] = madd2(v, y[8], c[1], t[8])
		c[2], t[7] = madd2(m, 5945444129596489281, c[2], c[0])
		c[1], c[0] = madd2(v, y[9], c[1], t[9])
		c[2], t[8] = madd2(m, 13341377791855249032, c[2], c[0])
		c[1], c[0] = madd2(v, y[10], c[1], t[10])
		c[2], t[9] = madd2(m, 15098257552581525310, c[2], c[0])
		c[1], c[0] = madd2(v, y[11], c[1], t[11])
		t[11], t[10] = madd3(m, 81882988782276106, c[0], c[2], c[1])
	}
	{
		// round 11
		v := x[11]
		c[1], c[0] = madd1(v, y[0], t[0])
		m := c[0] * 744663313386281181
		c[2] = madd0(m, 17626244516597989515, c[0])
		c[1], c[0] = madd2(v, y[1], c[1], t[1])
		c[2], z[0] = madd2(m, 16614129118623039618, c[2], c[0])
		c[1], c[0] = madd2(v, y[2], c[1], t[2])
		c[2], z[1] = madd2(m, 1588918198704579639, c[2], c[0])
		c[1], c[0] = madd2(v, y[3], c[1], t[3])
		c[2], z[2] = madd2(m, 10998096788944562424, c[2], c[0])
		c[1], c[0] = madd2(v, y[4], c[1], t[4])
		c[2], z[3] = madd2(m, 8204665564953313070, c[2], c[0])
		c[1], c[0] = madd2(v, y[5], c[1], t[5])
		c[2], z[4] = madd2(m, 9694500593442880912, c[2], c[0])
		c[1], c[0] = madd2(v, y[6], c[1], t[6])
		c[2], z[5] = madd2(m, 274362232328168196, c[2], c[0])
		c[1], c[0] = madd2(v, y[7], c[1], t[7])
		c[2], z[6] = madd2(m, 8105254717682411801, c[2], c[0])
		c[1], c[0] = madd2(v, y[8], c[1], t[8])
		c[2], z[7] = madd2(m, 5945444129596489281, c[2], c[0])
		c[1], c[0] = madd2(v, y[9], c[1], t[9])
		c[2], z[8] = madd2(m, 13341377791855249032, c[2], c[0])
		c[1], c[0] = madd2(v, y[10], c[1], t[10])
		c[2], z[9] = madd2(m, 15098257552581525310, c[2], c[0])
		c[1], c[0] = madd2(v, y[11], c[1], t[11])
		z[11], z[10] = madd3(m, 81882988782276106, c[0], c[2], c[1])
	}

	// if z > q --> z -= q
	// note: this is NOT constant time
	if !(z[11] < 81882988782276106 || (z[11] == 81882988782276106 && (z[10] < 15098257552581525310 || (z[10] == 15098257552581525310 && (z[9] < 13341377791855249032 || (z[9] == 13341377791855249032 && (z[8] < 5945444129596489281 || (z[8] == 5945444129596489281 && (z[7] < 8105254717682411801 || (z[7] == 8105254717682411801 && (z[6] < 274362232328168196 || (z[6] == 274362232328168196 && (z[5] < 9694500593442880912 || (z[5] == 9694500593442880912 && (z[4] < 8204665564953313070 || (z[4] == 8204665564953313070 && (z[3] < 10998096788944562424 || (z[3] == 10998096788944562424 && (z[2] < 1588918198704579639 || (z[2] == 1588918198704579639 && (z[1] < 16614129118623039618 || (z[1] == 16614129118623039618 && (z[0] < 17626244516597989515))))))))))))))))))))))) {
		var b uint64
		z[0], b = bits.Sub64(z[0], 17626244516597989515, 0)
		z[1], b = bits.Sub64(z[1], 16614129118623039618, b)
		z[2], b = bits.Sub64(z[2], 1588918198704579639, b)
		z[3], b = bits.Sub64(z[3], 10998096788944562424, b)
		z[4], b = bits.Sub64(z[4], 8204665564953313070, b)
		z[5], b = bits.Sub64(z[5], 9694500593442880912, b)
		z[6], b = bits.Sub64(z[6], 274362232328168196, b)
		z[7], b = bits.Sub64(z[7], 8105254717682411801, b)
		z[8], b = bits.Sub64(z[8], 5945444129596489281, b)
		z[9], b = bits.Sub64(z[9], 13341377791855249032, b)
		z[10], b = bits.Sub64(z[10], 15098257552581525310, b)
		z[11], _ = bits.Sub64(z[11], 81882988782276106, b)
	}
}

func _fromMontGeneric(z *Element) {
	// the following lines implement z = z * 1
	// with a modified CIOS montgomery multiplication
	{
		// m = z[0]n'[0] mod W
		m := z[0] * 744663313386281181
		C := madd0(m, 17626244516597989515, z[0])
		C, z[0] = madd2(m, 16614129118623039618, z[1], C)
		C, z[1] = madd2(m, 1588918198704579639, z[2], C)
		C, z[2] = madd2(m, 10998096788944562424, z[3], C)
		C, z[3] = madd2(m, 8204665564953313070, z[4], C)
		C, z[4] = madd2(m, 9694500593442880912, z[5], C)
		C, z[5] = madd2(m, 274362232328168196, z[6], C)
		C, z[6] = madd2(m, 8105254717682411801, z[7], C)
		C, z[7] = madd2(m, 5945444129596489281, z[8], C)
		C, z[8] = madd2(m, 13341377791855249032, z[9], C)
		C, z[9] = madd2(m, 15098257552581525310, z[10], C)
		C, z[10] = madd2(m, 81882988782276106, z[11], C)
		z[11] = C
	}
	{
		// m = z[0]n'[0] mod W
		m := z[0] * 744663313386281181
		C := madd0(m, 17626244516597989515, z[0])
		C, z[0] = madd2(m, 16614129118623039618, z[1], C)
		C, z[1] = madd2(m, 1588918198704579639, z[2], C)
		C, z[2] = madd2(m, 10998096788944562424, z[3], C)
		C, z[3] = madd2(m, 8204665564953313070, z[4], C)
		C, z[4] = madd2(m, 9694500593442880912, z[5], C)
		C, z[5] = madd2(m, 274362232328168196, z[6], C)
		C, z[6] = madd2(m, 8105254717682411801, z[7], C)
		C, z[7] = madd2(m, 5945444129596489281, z[8], C)
		C, z[8] = madd2(m, 13341377791855249032, z[9], C)
		C, z[9] = madd2(m, 15098257552581525310, z[10], C)
		C, z[10] = madd2(m, 81882988782276106, z[11], C)
		z[11] = C
	}
	{
		// m = z[0]n'[0] mod W
		m := z[0] * 744663313386281181
		C := madd0(m, 17626244516597989515, z[0])
		C, z[0] = madd2(m, 16614129118623039618, z[1], C)
		C, z[1] = madd2(m, 1588918198704579639, z[2], C)
		C, z[2] = madd2(m, 10998096788944562424, z[3], C)
		C, z[3] = madd2(m, 8204665564953313070, z[4], C)
		C, z[4] = madd2(m, 9694500593442880912, z[5], C)
		C, z[5] = madd2(m, 274362232328168196, z[6], C)
		C, z[6] = madd2(m, 8105254717682411801, z[7], C)
		C, z[7] = madd2(m, 5945444129596489281, z[8], C)
		C, z[8] = madd2(m, 13341377791855249032, z[9], C)
		C, z[9] = madd2(m, 15098257552581525310, z[10], C)
		C, z[10] = madd2(m, 81882988782276106, z[11], C)
		z[11] = C
	}
	{
		// m = z[0]n'[0] mod W
		m := z[0] * 744663313386281181
		C := madd0(m, 17626244516597989515, z[0])
		C, z[0] = madd2(m, 16614129118623039618, z[1], C)
		C, z[1] = madd2(m, 1588918198704579639, z[2], C)
		C, z[2] = madd2(m, 10998096788944562424, z[3], C)
		C, z[3] = madd2(m, 8204665564953313070, z[4], C)
		C, z[4] = madd2(m, 9694500593442880912, z[5], C)
		C, z[5] = madd2(m, 274362232328168196, z[6], C)
		C, z[6] = madd2(m, 8105254717682411801, z[7], C)
		C, z[7] = madd2(m, 5945444129596489281, z[8], C)
		C, z[8] = madd2(m, 13341377791855249032, z[9], C)
		C, z[9] = madd2(m, 15098257552581525310, z[10], C)
		C, z[10] = madd2(m, 81882988782276106, z[11], C)
		z[11] = C
	}
	{
		// m = z[0]n'[0] mod W
		m := z[0] * 744663313386281181
		C := madd0(m, 17626244516597989515, z[0])
		C, z[0] = madd2(m, 16614129118623039618, z[1], C)
		C, z[1] = madd2(m, 1588918198704579639, z[2], C)
		C, z[2] = madd2(m, 10998096788944562424, z[3], C)
		C, z[3] = madd2(m, 8204665564953313070, z[4], C)
		C, z[4] = madd2(m, 9694500593442880912, z[5], C)
		C, z[5] = madd2(m, 274362232328168196, z[6], C)
		C, z[6] = madd2(m, 8105254717682411801, z[7], C)
		C, z[7] = madd2(m, 5945444129596489281, z[8], C)
		C, z[8] = madd2(m, 13341377791855249032, z[9], C)
		C, z[9] = madd2(m, 15098257552581525310, z[10], C)
		C, z[10] = madd2(m, 81882988782276106, z[11], C)
		z[11] = C
	}
	{
		// m = z[0]n'[0] mod W
		m := z[0] * 744663313386281181
		C := madd0(m, 17626244516597989515, z[0])
		C, z[0] = madd2(m, 16614129118623039618, z[1], C)
		C, z[1] = madd2(m, 1588918198704579639, z[2], C)
		C, z[2] = madd2(m, 10998096788944562424, z[3], C)
		C, z[3] = madd2(m, 8204665564953313070, z[4], C)
		C, z[4] = madd2(m, 9694500593442880912, z[5], C)
		C, z[5] = madd2(m, 274362232328168196, z[6], C)
		C, z[6] = madd2(m, 8105254717682411801, z[7], C)
		C, z[7] = madd2(m, 5945444129596489281, z[8], C)
		C, z[8] = madd2(m, 13341377791855249032, z[9], C)
		C, z[9] = madd2(m, 15098257552581525310, z[10], C)
		C, z[10] = madd2(m, 81882988782276106, z[11], C)
		z[11] = C
	}
	{
		// m = z[0]n'[0] mod W
		m := z[0] * 744663313386281181
		C := madd0(m, 17626244516597989515, z[0])
		C, z[0] = madd2(m, 16614129118623039618, z[1], C)
		C, z[1] = madd2(m, 1588918198704579639, z[2], C)
		C, z[2] = madd2(m, 10998096788944562424, z[3], C)
		C, z[3] = madd2(m, 8204665564953313070, z[4], C)
		C, z[4] = madd2(m, 9694500593442880912, z[5], C)
		C, z[5] = madd2(m, 274362232328168196, z[6], C)
		C, z[6] = madd2(m, 8105254717682411801, z[7], C)
		C, z[7] = madd2(m, 5945444129596489281, z[8], C)
		C, z[8] = madd2(m, 13341377791855249032, z[9], C)
		C, z[9] = madd2(m, 15098257552581525310, z[10], C)
		C, z[10] = madd2(m, 81882988782276106, z[11], C)
		z[11] = C
	}
	{
		// m = z[0]n'[0] mod W
		m := z[0] * 744663313386281181
		C := madd0(m, 17626244516597989515, z[0])
		C, z[0] = madd2(m, 16614129118623039618, z[1], C)
		C, z[1] = madd2(m, 1588918198704579639, z[2], C)
		C, z[2] = madd2(m, 10998096788944562424, z[3], C)
		C, z[3] = madd2(m, 8204665564953313070, z[4], C)
		C, z[4] = madd2(m, 9694500593442880912, z[5], C)
		C, z[5] = madd2(m, 274362232328168196, z[6], C)
		C, z[6] = madd2(m, 8105254717682411801, z[7], C)
		C, z[7] = madd2(m, 5945444129596489281, z[8], C)
		C, z[8] = madd2(m, 13341377791855249032, z[9], C)
		C, z[9] = madd2(m, 15098257552581525310, z[10], C)
		C, z[10] = madd2(m, 81882988782276106, z[11], C)
		z[11] = C
	}
	{
		// m = z[0]n'[0] mod W
		m := z[0] * 744663313386281181
		C := madd0(m, 17626244516597989515, z[0])
		C, z[0] = madd2(m, 16614129118623039618, z[1], C)
		C, z[1] = madd2(m, 1588918198704579639, z[2], C)
		C, z[2] = madd2(m, 10998096788944562424, z[3], C)
		C, z[3] = madd2(m, 8204665564953313070, z[4], C)
		C, z[4] = madd2(m, 9694500593442880912, z[5], C)
		C, z[5] = madd2(m, 274362232328168196, z[6], C)
		C, z[6] = madd2(m, 8105254717682411801, z[7], C)
		C, z[7] = madd2(m, 5945444129596489281, z[8], C)
		C, z[8] = madd2(m, 13341377791855249032, z[9], C)
		C, z[9] = madd2(m, 15098257552581525310, z[10], C)
		C, z[10] = madd2(m, 81882988782276106, z[11], C)
		z[11] = C
	}
	{
		// m = z[0]n'[0] mod W
		m := z[0] * 744663313386281181
		C := madd0(m, 17626244516597989515, z[0])
		C, z[0] = madd2(m, 16614129118623039618, z[1], C)
		C, z[1] = madd2(m, 1588918198704579639, z[2], C)
		C, z[2] = madd2(m, 10998096788944562424, z[3], C)
		C, z[3] = madd2(m, 8204665564953313070, z[4], C)
		C, z[4] = madd2(m, 9694500593442880912, z[5], C)
		C, z[5] = madd2(m, 274362232328168196, z[6], C)
		C, z[6] = madd2(m, 8105254717682411801, z[7], C)
		C, z[7] = madd2(m, 5945444129596489281, z[8], C)
		C, z[8] = madd2(m, 13341377791855249032, z[9], C)
		C, z[9] = madd2(m, 15098257552581525310, z[10], C)
		C, z[10] = madd2(m, 81882988782276106, z[11], C)
		z[11] = C
	}
	{
		// m = z[0]n'[0] mod W
		m := z[0] * 744663313386281181
		C := madd0(m, 17626244516597989515, z[0])
		C, z[0] = madd2(m, 16614129118623039618, z[1], C)
		C, z[1] = madd2(m, 1588918198704579639, z[2], C)
		C, z[2] = madd2(m, 10998096788944562424, z[3], C)
		C, z[3] = madd2(m, 8204665564953313070, z[4], C)
		C, z[4] = madd2(m, 9694500593442880912, z[5], C)
		C, z[5] = madd2(m, 274362232328168196, z[6], C)
		C, z[6] = madd2(m, 8105254717682411801, z[7], C)
		C, z[7] = madd2(m, 5945444129596489281, z[8], C)
		C, z[8] = madd2(m, 13341377791855249032, z[9], C)
		C, z[9] = madd2(m, 15098257552581525310, z[10], C)
		C, z[10] = madd2(m, 81882988782276106, z[11], C)
		z[11] = C
	}
	{
		// m = z[0]n'[0] mod W
		m := z[0] * 744663313386281181
		C := madd0(m, 17626244516597989515, z[0])
		C, z[0] = madd2(m, 16614129118623039618, z[1], C)
		C, z[1] = madd2(m, 1588918198704579639, z[2], C)
		C, z[2] = madd2(m, 10998096788944562424, z[3], C)
		C, z[3] = madd2(m, 8204665564953313070, z[4], C)
		C, z[4] = madd2(m, 9694500593442880912, z[5], C)
		C, z[5] = madd2(m, 274362232328168196, z[6], C)
		C, z[6] = madd2(m, 8105254717682411801, z[7], C)
		C, z[7] = madd2(m, 5945444129596489281, z[8], C)
		C, z[8] = madd2(m, 13341377791855249032, z[9], C)
		C, z[9] = madd2(m, 15098257552581525310, z[10], C)
		C, z[10] = madd2(m, 81882988782276106, z[11], C)
		z[11] = C
	}

	// if z > q --> z -= q
	// note: this is NOT constant time
	if !(z[11] < 81882988782276106 || (z[11] == 81882988782276106 && (z[10] < 15098257552581525310 || (z[10] == 15098257552581525310 && (z[9] < 13341377791855249032 || (z[9] == 13341377791855249032 && (z[8] < 5945444129596489281 || (z[8] == 5945444129596489281 && (z[7] < 8105254717682411801 || (z[7] == 8105254717682411801 && (z[6] < 274362232328168196 || (z[6] == 274362232328168196 && (z[5] < 9694500593442880912 || (z[5] == 9694500593442880912 && (z[4] < 8204665564953313070 || (z[4] == 8204665564953313070 && (z[3] < 10998096788944562424 || (z[3] == 10998096788944562424 && (z[2] < 1588918198704579639 || (z[2] == 1588918198704579639 && (z[1] < 16614129118623039618 || (z[1] == 16614129118623039618 && (z[0] < 17626244516597989515))))))))))))))))))))))) {
		var b uint64
		z[0], b = bits.Sub64(z[0], 17626244516597989515, 0)
		z[1], b = bits.Sub64(z[1], 16614129118623039618, b)
		z[2], b = bits.Sub64(z[2], 1588918198704579639, b)
		z[3], b = bits.Sub64(z[3], 10998096788944562424, b)
		z[4], b = bits.Sub64(z[4], 8204665564953313070, b)
		z[5], b = bits.Sub64(z[5], 9694500593442880912, b)
		z[6], b = bits.Sub64(z[6], 274362232328168196, b)
		z[7], b = bits.Sub64(z[7], 8105254717682411801, b)
		z[8], b = bits.Sub64(z[8], 5945444129596489281, b)
		z[9], b = bits.Sub64(z[9], 13341377791855249032, b)
		z[10], b = bits.Sub64(z[10], 15098257552581525310, b)
		z[11], _ = bits.Sub64(z[11], 81882988782276106, b)
	}
}

func _addGeneric(z, x, y *Element) {
	var carry uint64

	z[0], carry = bits.Add64(x[0], y[0], 0)
	z[1], carry = bits.Add64(x[1], y[1], carry)
	z[2], carry = bits.Add64(x[2], y[2], carry)
	z[3], carry = bits.Add64(x[3], y[3], carry)
	z[4], carry = bits.Add64(x[4], y[4], carry)
	z[5], carry = bits.Add64(x[5], y[5], carry)
	z[6], carry = bits.Add64(x[6], y[6], carry)
	z[7], carry = bits.Add64(x[7], y[7], carry)
	z[8], carry = bits.Add64(x[8], y[8], carry)
	z[9], carry = bits.Add64(x[9], y[9], carry)
	z[10], carry = bits.Add64(x[10], y[10], carry)
	z[11], _ = bits.Add64(x[11], y[11], carry)

	// if z > q --> z -= q
	// note: this is NOT constant time
	if !(z[11] < 81882988782276106 || (z[11] == 81882988782276106 && (z[10] < 15098257552581525310 || (z[10] == 15098257552581525310 && (z[9] < 13341377791855249032 || (z[9] == 13341377791855249032 && (z[8] < 5945444129596489281 || (z[8] == 5945444129596489281 && (z[7] < 8105254717682411801 || (z[7] == 8105254717682411801 && (z[6] < 274362232328168196 || (z[6] == 274362232328168196 && (z[5] < 9694500593442880912 || (z[5] == 9694500593442880912 && (z[4] < 8204665564953313070 || (z[4] == 8204665564953313070 && (z[3] < 10998096788944562424 || (z[3] == 10998096788944562424 && (z[2] < 1588918198704579639 || (z[2] == 1588918198704579639 && (z[1] < 16614129118623039618 || (z[1] == 16614129118623039618 && (z[0] < 17626244516597989515))))))))))))))))))))))) {
		var b uint64
		z[0], b = bits.Sub64(z[0], 17626244516597989515, 0)
		z[1], b = bits.Sub64(z[1], 16614129118623039618, b)
		z[2], b = bits.Sub64(z[2], 1588918198704579639, b)
		z[3], b = bits.Sub64(z[3], 10998096788944562424, b)
		z[4], b = bits.Sub64(z[4], 8204665564953313070, b)
		z[5], b = bits.Sub64(z[5], 9694500593442880912, b)
		z[6], b = bits.Sub64(z[6], 274362232328168196, b)
		z[7], b = bits.Sub64(z[7], 8105254717682411801, b)
		z[8], b = bits.Sub64(z[8], 5945444129596489281, b)
		z[9], b = bits.Sub64(z[9], 13341377791855249032, b)
		z[10], b = bits.Sub64(z[10], 15098257552581525310, b)
		z[11], _ = bits.Sub64(z[11], 81882988782276106, b)
	}
}

func _doubleGeneric(z, x *Element) {
	var carry uint64

	z[0], carry = bits.Add64(x[0], x[0], 0)
	z[1], carry = bits.Add64(x[1], x[1], carry)
	z[2], carry = bits.Add64(x[2], x[2], carry)
	z[3], carry = bits.Add64(x[3], x[3], carry)
	z[4], carry = bits.Add64(x[4], x[4], carry)
	z[5], carry = bits.Add64(x[5], x[5], carry)
	z[6], carry = bits.Add64(x[6], x[6], carry)
	z[7], carry = bits.Add64(x[7], x[7], carry)
	z[8], carry = bits.Add64(x[8], x[8], carry)
	z[9], carry = bits.Add64(x[9], x[9], carry)
	z[10], carry = bits.Add64(x[10], x[10], carry)
	z[11], _ = bits.Add64(x[11], x[11], carry)

	// if z > q --> z -= q
	// note: this is NOT constant time
	if !(z[11] < 81882988782276106 || (z[11] == 81882988782276106 && (z[10] < 15098257552581525310 || (z[10] == 15098257552581525310 && (z[9] < 13341377791855249032 || (z[9] == 13341377791855249032 && (z[8] < 5945444129596489281 || (z[8] == 5945444129596489281 && (z[7] < 8105254717682411801 || (z[7] == 8105254717682411801 && (z[6] < 274362232328168196 || (z[6] == 274362232328168196 && (z[5] < 9694500593442880912 || (z[5] == 9694500593442880912 && (z[4] < 8204665564953313070 || (z[4] == 8204665564953313070 && (z[3] < 10998096788944562424 || (z[3] == 10998096788944562424 && (z[2] < 1588918198704579639 || (z[2] == 1588918198704579639 && (z[1] < 16614129118623039618 || (z[1] == 16614129118623039618 && (z[0] < 17626244516597989515))))))))))))))))))))))) {
		var b uint64
		z[0], b = bits.Sub64(z[0], 17626244516597989515, 0)
		z[1], b = bits.Sub64(z[1], 16614129118623039618, b)
		z[2], b = bits.Sub64(z[2], 1588918198704579639, b)
		z[3], b = bits.Sub64(z[3], 10998096788944562424, b)
		z[4], b = bits.Sub64(z[4], 8204665564953313070, b)
		z[5], b = bits.Sub64(z[5], 9694500593442880912, b)
		z[6], b = bits.Sub64(z[6], 274362232328168196, b)
		z[7], b = bits.Sub64(z[7], 8105254717682411801, b)
		z[8], b = bits.Sub64(z[8], 5945444129596489281, b)
		z[9], b = bits.Sub64(z[9], 13341377791855249032, b)
		z[10], b = bits.Sub64(z[10], 15098257552581525310, b)
		z[11], _ = bits.Sub64(z[11], 81882988782276106, b)
	}
}

func _subGeneric(z, x, y *Element) {
	var b uint64
	z[0], b = bits.Sub64(x[0], y[0], 0)
	z[1], b = bits.Sub64(x[1], y[1], b)
	z[2], b = bits.Sub64(x[2], y[2], b)
	z[3], b = bits.Sub64(x[3], y[3], b)
	z[4], b = bits.Sub64(x[4], y[4], b)
	z[5], b = bits.Sub64(x[5], y[5], b)
	z[6], b = bits.Sub64(x[6], y[6], b)
	z[7], b = bits.Sub64(x[7], y[7], b)
	z[8], b = bits.Sub64(x[8], y[8], b)
	z[9], b = bits.Sub64(x[9], y[9], b)
	z[10], b = bits.Sub64(x[10], y[10], b)
	z[11], b = bits.Sub64(x[11], y[11], b)
	if b != 0 {
		var c uint64
		z[0], c = bits.Add64(z[0], 17626244516597989515, 0)
		z[1], c = bits.Add64(z[1], 16614129118623039618, c)
		z[2], c = bits.Add64(z[2], 1588918198704579639, c)
		z[3], c = bits.Add64(z[3], 10998096788944562424, c)
		z[4], c = bits.Add64(z[4], 8204665564953313070, c)
		z[5], c = bits.Add64(z[5], 9694500593442880912, c)
		z[6], c = bits.Add64(z[6], 274362232328168196, c)
		z[7], c = bits.Add64(z[7], 8105254717682411801, c)
		z[8], c = bits.Add64(z[8], 5945444129596489281, c)
		z[9], c = bits.Add64(z[9], 13341377791855249032, c)
		z[10], c = bits.Add64(z[10], 15098257552581525310, c)
		z[11], _ = bits.Add64(z[11], 81882988782276106, c)
	}
}

func _negGeneric(z, x *Element) {
	if x.IsZero() {
		z.SetZero()
		return
	}
	var borrow uint64
	z[0], borrow = bits.Sub64(17626244516597989515, x[0], 0)
	z[1], borrow = bits.Sub64(16614129118623039618, x[1], borrow)
	z[2], borrow = bits.Sub64(1588918198704579639, x[2], borrow)
	z[3], borrow = bits.Sub64(10998096788944562424, x[3], borrow)
	z[4], borrow = bits.Sub64(8204665564953313070, x[4], borrow)
	z[5], borrow = bits.Sub64(9694500593442880912, x[5], borrow)
	z[6], borrow = bits.Sub64(274362232328168196, x[6], borrow)
	z[7], borrow = bits.Sub64(8105254717682411801, x[7], borrow)
	z[8], borrow = bits.Sub64(5945444129596489281, x[8], borrow)
	z[9], borrow = bits.Sub64(13341377791855249032, x[9], borrow)
	z[10], borrow = bits.Sub64(15098257552581525310, x[10], borrow)
	z[11], _ = bits.Sub64(81882988782276106, x[11], borrow)
}

func _reduceGeneric(z *Element) {

	// if z > q --> z -= q
	// note: this is NOT constant time
	if !(z[11] < 81882988782276106 || (z[11] == 81882988782276106 && (z[10] < 15098257552581525310 || (z[10] == 15098257552581525310 && (z[9] < 13341377791855249032 || (z[9] == 13341377791855249032 && (z[8] < 5945444129596489281 || (z[8] == 5945444129596489281 && (z[7] < 8105254717682411801 || (z[7] == 8105254717682411801 && (z[6] < 274362232328168196 || (z[6] == 274362232328168196 && (z[5] < 9694500593442880912 || (z[5] == 9694500593442880912 && (z[4] < 8204665564953313070 || (z[4] == 8204665564953313070 && (z[3] < 10998096788944562424 || (z[3] == 10998096788944562424 && (z[2] < 1588918198704579639 || (z[2] == 1588918198704579639 && (z[1] < 16614129118623039618 || (z[1] == 16614129118623039618 && (z[0] < 17626244516597989515))))))))))))))))))))))) {
		var b uint64
		z[0], b = bits.Sub64(z[0], 17626244516597989515, 0)
		z[1], b = bits.Sub64(z[1], 16614129118623039618, b)
		z[2], b = bits.Sub64(z[2], 1588918198704579639, b)
		z[3], b = bits.Sub64(z[3], 10998096788944562424, b)
		z[4], b = bits.Sub64(z[4], 8204665564953313070, b)
		z[5], b = bits.Sub64(z[5], 9694500593442880912, b)
		z[6], b = bits.Sub64(z[6], 274362232328168196, b)
		z[7], b = bits.Sub64(z[7], 8105254717682411801, b)
		z[8], b = bits.Sub64(z[8], 5945444129596489281, b)
		z[9], b = bits.Sub64(z[9], 13341377791855249032, b)
		z[10], b = bits.Sub64(z[10], 15098257552581525310, b)
		z[11], _ = bits.Sub64(z[11], 81882988782276106, b)
	}
}

func mulByConstant(z *Element, c uint8) {
	switch c {
	case 0:
		z.SetZero()
		return
	case 1:
		return
	case 2:
		z.Double(z)
		return
	case 3:
		_z := *z
		z.Double(z).Add(z, &_z)
	case 5:
		_z := *z
		z.Double(z).Double(z).Add(z, &_z)
	default:
		var y Element
		y.SetUint64(uint64(c))
		z.Mul(z, &y)
	}
}

// BatchInvert returns a new slice with every element inverted.
// Uses Montgomery batch inversion trick
func BatchInvert(a []Element) []Element {
	res := make([]Element, len(a))
	if len(a) == 0 {
		return res
	}

	zeroes := make([]bool, len(a))
	accumulator := One()

	for i := 0; i < len(a); i++ {
		if a[i].IsZero() {
			zeroes[i] = true
			continue
		}
		res[i] = accumulator
		accumulator.Mul(&accumulator, &a[i])
	}

	accumulator.Inverse(&accumulator)

	for i := len(a) - 1; i >= 0; i-- {
		if zeroes[i] {
			continue
		}
		res[i].Mul(&res[i], &accumulator)
		accumulator.Mul(&accumulator, &a[i])
	}

	return res
}

func _butterflyGeneric(a, b *Element) {
	t := *a
	a.Add(a, b)
	b.Sub(&t, b)
}

// BitLen returns the minimum number of bits needed to represent z
// returns 0 if z == 0
func (z *Element) BitLen() int {
	if z[11] != 0 {
		return 704 + bits.Len64(z[11])
	}
	if z[10] != 0 {
		return 640 + bits.Len64(z[10])
	}
	if z[9] != 0 {
		return 576 + bits.Len64(z[9])
	}
	if z[8] != 0 {
		return 512 + bits.Len64(z[8])
	}
	if z[7] != 0 {
		return 448 + bits.Len64(z[7])
	}
	if z[6] != 0 {
		return 384 + bits.Len64(z[6])
	}
	if z[5] != 0 {
		return 320 + bits.Len64(z[5])
	}
	if z[4] != 0 {
		return 256 + bits.Len64(z[4])
	}
	if z[3] != 0 {
		return 192 + bits.Len64(z[3])
	}
	if z[2] != 0 {
		return 128 + bits.Len64(z[2])
	}
	if z[1] != 0 {
		return 64 + bits.Len64(z[1])
	}
	return bits.Len64(z[0])
}

// generated by github.com/mmcloughlin/addchain

func (z *Element) expBySqrtExp(x *Element) *Element {
	// the addition chain:
	//
	//	_10       = 2*1
	//	_11       = 1 + _10
	//	_101      = _10 + _11
	//	_111      = _10 + _101
	//	_1001     = _10 + _111
	//	_1011     = _10 + _1001
	//	_1101     = _10 + _1011
	//	_1111     = _10 + _1101
	//	_10001    = _10 + _1111
	//	_10010    = 1 + _10001
	//	_10011    = 1 + _10010
	//	_10111    = _101 + _10010
	//	_11001    = _10 + _10111
	//	_11011    = _10 + _11001
	//	_11101    = _10 + _11011
	//	_11111    = _10 + _11101
	//	_100001   = _10 + _11111
	//	_100011   = _10 + _100001
	//	_100101   = _10 + _100011
	//	_100111   = _10 + _100101
	//	_101001   = _10 + _100111
	//	_101011   = _10 + _101001
	//	_101101   = _10 + _101011
	//	_101111   = _10 + _101101
	//	_110001   = _10 + _101111
	//	_110011   = _10 + _110001
	//	_110101   = _10 + _110011
	//	_110111   = _10 + _110101
	//	_111001   = _10 + _110111
	//	_111011   = _10 + _111001
	//	_111101   = _10 + _111011
	//	_1111010  = 2*_111101
	//	_1111111  = _101 + _1111010
	//	_11111110 = 2*_1111111
	//	_11111111 = 1 + _11111110
	//	i43       = ((_100001 + _11111111) << 3 + _10111) << 2 + 1
	//	i65       = ((i43 << 9 + _1001) << 7 + _11111) << 4
	//	i82       = ((_111 + i65) << 9 + _1111) << 5 + _111
	//	i111      = ((i82 << 11 + _101011) << 7 + _100011) << 9
	//	i139      = ((_11111 + i111) << 8 + _100101) << 17 + _100111
	//	i161      = ((i139 << 4 + _1101) << 9 + _11111111) << 7
	//	i176      = ((_11111 + i161) << 6 + _10111) << 6 + _1001
	//	i198      = ((i176 << 4 + _11) << 6 + _11) << 10
	//	i214      = ((_110101 + i198) << 2 + 1) << 11 + _11101
	//	i238      = ((i214 << 6 + _101) << 7 + _1101) << 9
	//	i259      = ((_100001 + i238) << 7 + _100101) << 11 + _100111
	//	i287      = ((i259 << 7 + _101111) << 6 + _11111) << 13
	//	i302      = ((_100001 + i287) << 6 + _111011) << 6 + _111001
	//	i329      = ((i302 << 10 + _10111) << 11 + _111101) << 4
	//	i346      = ((_1101 + i329) << 8 + _110001) << 6 + _110001
	//	i366      = ((i346 << 5 + _11001) << 3 + _11) << 10
	//	i382      = ((_100111 + i366) << 5 + _1001) << 8 + _11001
	//	i407      = ((i382 << 10 + _1111) << 7 + _11101) << 6
	//	i427      = ((_11101 + i407) << 9 + _11111111) << 8 + _100101
	//	i454      = ((i427 << 6 + _101101) << 10 + _100011) << 9
	//	i474      = ((_1001 + i454) << 8 + _1101) << 9 + _100111
	//	i499      = ((i474 << 8 + _100011) << 6 + _101101) << 9
	//	i515      = ((_100101 + i499) << 4 + _1111) << 9 + _1111111
	//	i540      = ((i515 << 6 + _11001) << 8 + _111) << 9
	//	i555      = ((_111011 + i540) << 5 + _10011) << 7 + _100111
	//	i577      = ((i555 << 5 + _10111) << 9 + _111001) << 6
	//	i591      = ((_111101 + i577) << 9 + _11111111) << 2 + _11
	//	i612      = ((i591 << 7 + _10111) << 6 + _10011) << 6
	//	i630      = ((_101 + i612) << 9 + _10001) << 6 + _11011
	//	i657      = ((i630 << 10 + _100101) << 7 + _110011) << 8
	//	i670      = ((_111101 + i657) << 7 + _100011) << 3 + _111
	//	i696      = ((i670 << 10 + _1011) << 11 + _110011) << 3
	//	i713      = ((_111 + i696) << 9 + _101011) << 5 + _10111
	//	i734      = ((i713 << 7 + _101011) << 2 + _11) << 10
	//	i753      = ((_101001 + i734) << 10 + _110111) << 6 + _111001
	//	i776      = ((i753 << 6 + _101001) << 9 + _100111) << 6
	//	i788      = ((_110011 + i776) << 7 + _100001) << 2 + _11
	//	i827      = ((i788 << 21 + 1) << 11 + _101111) << 5
	//	return      ((_1001 + i827) << 7 + _11101) << 46 + _100011
	//
	// Operations: 753 squares 130 multiplies
	//
	// Generated by github.com/mmcloughlin/addchain v0.4.0.

	// Allocate Temporaries.
	var t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26, t27, t28, t29, t30 Element
	// Step 1: t14 = x^0x2
	t14.Square(x)

	// Step 2: t3 = x^0x3
	t3.Mul(x, &t14)

	// Step 3: t18 = x^0x5
	t18.Mul(&t14, &t3)

	// Step 4: t12 = x^0x7
	t12.Mul(&t14, &t18)

	// Step 5: t1 = x^0x9
	t1.Mul(&t14, &t12)

	// Step 6: t13 = x^0xb
	t13.Mul(&t14, &t1)

	// Step 7: t26 = x^0xd
	t26.Mul(&t14, &t13)

	// Step 8: t24 = x^0xf
	t24.Mul(&t14, &t26)

	// Step 9: t17 = x^0x11
	t17.Mul(&t14, &t24)

	// Step 10: z = x^0x12
	z.Mul(x, &t17)

	// Step 11: t19 = x^0x13
	t19.Mul(x, z)

	// Step 12: t11 = x^0x17
	t11.Mul(&t18, z)

	// Step 13: t22 = x^0x19
	t22.Mul(&t14, &t11)

	// Step 14: t16 = x^0x1b
	t16.Mul(&t14, &t22)

	// Step 15: t0 = x^0x1d
	t0.Mul(&t14, &t16)

	// Step 16: t28 = x^0x1f
	t28.Mul(&t14, &t0)

	// Step 17: t4 = x^0x21
	t4.Mul(&t14, &t28)

	// Step 18: z = x^0x23
	z.Mul(&t14, &t4)

	// Step 19: t15 = x^0x25
	t15.Mul(&t14, z)

	// Step 20: t6 = x^0x27
	t6.Mul(&t14, &t15)

	// Step 21: t7 = x^0x29
	t7.Mul(&t14, &t6)

	// Step 22: t10 = x^0x2b
	t10.Mul(&t14, &t7)

	// Step 23: t25 = x^0x2d
	t25.Mul(&t14, &t10)

	// Step 24: t2 = x^0x2f
	t2.Mul(&t14, &t25)

	// Step 25: t27 = x^0x31
	t27.Mul(&t14, &t2)

	// Step 26: t5 = x^0x33
	t5.Mul(&t14, &t27)

	// Step 27: t29 = x^0x35
	t29.Mul(&t14, &t5)

	// Step 28: t9 = x^0x37
	t9.Mul(&t14, &t29)

	// Step 29: t8 = x^0x39
	t8.Mul(&t14, &t9)

	// Step 30: t21 = x^0x3b
	t21.Mul(&t14, &t8)

	// Step 31: t14 = x^0x3d
	t14.Mul(&t14, &t21)

	// Step 32: t20 = x^0x7a
	t20.Square(&t14)

	// Step 33: t23 = x^0x7f
	t23.Mul(&t18, &t20)

	// Step 34: t20 = x^0xfe
	t20.Square(&t23)

	// Step 35: t20 = x^0xff
	t20.Mul(x, &t20)

	// Step 36: t30 = x^0x120
	t30.Mul(&t4, &t20)

	// Step 39: t30 = x^0x900
	for s := 0; s < 3; s++ {
		t30.Square(&t30)
	}

	// Step 40: t30 = x^0x917
	t30.Mul(&t11, &t30)

	// Step 42: t30 = x^0x245c
	for s := 0; s < 2; s++ {
		t30.Square(&t30)
	}

	// Step 43: t30 = x^0x245d
	t30.Mul(x, &t30)

	// Step 52: t30 = x^0x48ba00
	for s := 0; s < 9; s++ {
		t30.Square(&t30)
	}

	// Step 53: t30 = x^0x48ba09
	t30.Mul(&t1, &t30)

	// Step 60: t30 = x^0x245d0480
	for s := 0; s < 7; s++ {
		t30.Square(&t30)
	}

	// Step 61: t30 = x^0x245d049f
	t30.Mul(&t28, &t30)

	// Step 65: t30 = x^0x245d049f0
	for s := 0; s < 4; s++ {
		t30.Square(&t30)
	}

	// Step 66: t30 = x^0x245d049f7
	t30.Mul(&t12, &t30)

	// Step 75: t30 = x^0x48ba093ee00
	for s := 0; s < 9; s++ {
		t30.Square(&t30)
	}

	// Step 76: t30 = x^0x48ba093ee0f
	t30.Mul(&t24, &t30)

	// Step 81: t30 = x^0x9174127dc1e0
	for s := 0; s < 5; s++ {
		t30.Square(&t30)
	}

	// Step 82: t30 = x^0x9174127dc1e7
	t30.Mul(&t12, &t30)

	// Step 93: t30 = x^0x48ba093ee0f3800
	for s := 0; s < 11; s++ {
		t30.Square(&t30)
	}

	// Step 94: t30 = x^0x48ba093ee0f382b
	t30.Mul(&t10, &t30)

	// Step 101: t30 = x^0x245d049f7079c1580
	for s := 0; s < 7; s++ {
		t30.Square(&t30)
	}

	// Step 102: t30 = x^0x245d049f7079c15a3
	t30.Mul(z, &t30)

	// Step 111: t30 = x^0x48ba093ee0f382b4600
	for s := 0; s < 9; s++ {
		t30.Square(&t30)
	}

	// Step 112: t30 = x^0x48ba093ee0f382b461f
	t30.Mul(&t28, &t30)

	// Step 120: t30 = x^0x48ba093ee0f382b461f00
	for s := 0; s < 8; s++ {
		t30.Square(&t30)
	}

	// Step 121: t30 = x^0x48ba093ee0f382b461f25
	t30.Mul(&t15, &t30)

	// Step 138: t30 = x^0x9174127dc1e70568c3e4a0000
	for s := 0; s < 17; s++ {
		t30.Square(&t30)
	}

	// Step 139: t30 = x^0x9174127dc1e70568c3e4a0027
	t30.Mul(&t6, &t30)

	// Step 143: t30 = x^0x9174127dc1e70568c3e4a00270
	for s := 0; s < 4; s++ {
		t30.Square(&t30)
	}

	// Step 144: t30 = x^0x9174127dc1e70568c3e4a0027d
	t30.Mul(&t26, &t30)

	// Step 153: t30 = x^0x122e824fb83ce0ad187c94004fa00
	for s := 0; s < 9; s++ {
		t30.Square(&t30)
	}

	// Step 154: t30 = x^0x122e824fb83ce0ad187c94004faff
	t30.Mul(&t20, &t30)

	// Step 161: t30 = x^0x9174127dc1e70568c3e4a0027d7f80
	for s := 0; s < 7; s++ {
		t30.Square(&t30)
	}

	// Step 162: t30 = x^0x9174127dc1e70568c3e4a0027d7f9f
	t30.Mul(&t28, &t30)

	// Step 168: t30 = x^0x245d049f7079c15a30f928009f5fe7c0
	for s := 0; s < 6; s++ {
		t30.Square(&t30)
	}

	// Step 169: t30 = x^0x245d049f7079c15a30f928009f5fe7d7
	t30.Mul(&t11, &t30)

	// Step 175: t30 = x^0x9174127dc1e70568c3e4a0027d7f9f5c0
	for s := 0; s < 6; s++ {
		t30.Square(&t30)
	}

	// Step 176: t30 = x^0x9174127dc1e70568c3e4a0027d7f9f5c9
	t30.Mul(&t1, &t30)

	// Step 180: t30 = x^0x9174127dc1e70568c3e4a0027d7f9f5c90
	for s := 0; s < 4; s++ {
		t30.Square(&t30)
	}

	// Step 181: t30 = x^0x9174127dc1e70568c3e4a0027d7f9f5c93
	t30.Mul(&t3, &t30)

	// Step 187: t30 = x^0x245d049f7079c15a30f928009f5fe7d724c0
	for s := 0; s < 6; s++ {
		t30.Square(&t30)
	}

	// Step 188: t30 = x^0x245d049f7079c15a30f928009f5fe7d724c3
	t30.Mul(&t3, &t30)

	// Step 198: t30 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c00
	for s := 0; s < 10; s++ {
		t30.Square(&t30)
	}

	// Step 199: t29 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c35
	t29.Mul(&t29, &t30)

	// Step 201: t29 = x^0x245d049f7079c15a30f928009f5fe7d724c30d4
	for s := 0; s < 2; s++ {
		t29.Square(&t29)
	}

	// Step 202: t29 = x^0x245d049f7079c15a30f928009f5fe7d724c30d5
	t29.Mul(x, &t29)

	// Step 213: t29 = x^0x122e824fb83ce0ad187c94004faff3eb926186a800
	for s := 0; s < 11; s++ {
		t29.Square(&t29)
	}

	// Step 214: t29 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d
	t29.Mul(&t0, &t29)

	// Step 220: t29 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa0740
	for s := 0; s < 6; s++ {
		t29.Square(&t29)
	}

	// Step 221: t29 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa0745
	t29.Mul(&t18, &t29)

	// Step 228: t29 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a280
	for s := 0; s < 7; s++ {
		t29.Square(&t29)
	}

	// Step 229: t29 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d
	t29.Mul(&t26, &t29)

	// Step 238: t29 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a00
	for s := 0; s < 9; s++ {
		t29.Square(&t29)
	}

	// Step 239: t29 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a21
	t29.Mul(&t4, &t29)

	// Step 246: t29 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d1080
	for s := 0; s < 7; s++ {
		t29.Square(&t29)
	}

	// Step 247: t29 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a5
	t29.Mul(&t15, &t29)

	// Step 258: t29 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d1468852800
	for s := 0; s < 11; s++ {
		t29.Square(&t29)
	}

	// Step 259: t29 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d1468852827
	t29.Mul(&t6, &t29)

	// Step 266: t29 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a3442941380
	for s := 0; s < 7; s++ {
		t29.Square(&t29)
	}

	// Step 267: t29 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af
	t29.Mul(&t2, &t29)

	// Step 273: t29 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebc0
	for s := 0; s < 6; s++ {
		t29.Square(&t29)
	}

	// Step 274: t28 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf
	t28.Mul(&t28, &t29)

	// Step 287: t28 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be000
	for s := 0; s < 13; s++ {
		t28.Square(&t28)
	}

	// Step 288: t28 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021
	t28.Mul(&t4, &t28)

	// Step 294: t28 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef80840
	for s := 0; s < 6; s++ {
		t28.Square(&t28)
	}

	// Step 295: t28 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087b
	t28.Mul(&t21, &t28)

	// Step 301: t28 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ec0
	for s := 0; s < 6; s++ {
		t28.Square(&t28)
	}

	// Step 302: t28 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef9
	t28.Mul(&t8, &t28)

	// Step 312: t28 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be400
	for s := 0; s < 10; s++ {
		t28.Square(&t28)
	}

	// Step 313: t28 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be417
	t28.Mul(&t11, &t28)

	// Step 324: t28 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b800
	for s := 0; s < 11; s++ {
		t28.Square(&t28)
	}

	// Step 325: t28 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83d
	t28.Mul(&t14, &t28)

	// Step 329: t28 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83d0
	for s := 0; s < 4; s++ {
		t28.Square(&t28)
	}

	// Step 330: t28 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd
	t28.Mul(&t26, &t28)

	// Step 338: t28 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd00
	for s := 0; s < 8; s++ {
		t28.Square(&t28)
	}

	// Step 339: t28 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31
	t28.Mul(&t27, &t28)

	// Step 345: t28 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c40
	for s := 0; s < 6; s++ {
		t28.Square(&t28)
	}

	// Step 346: t27 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71
	t27.Mul(&t27, &t28)

	// Step 351: t27 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e20
	for s := 0; s < 5; s++ {
		t27.Square(&t27)
	}

	// Step 352: t27 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39
	t27.Mul(&t22, &t27)

	// Step 355: t27 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71c8
	for s := 0; s < 3; s++ {
		t27.Square(&t27)
	}

	// Step 356: t27 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb
	t27.Mul(&t3, &t27)

	// Step 366: t27 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c00
	for s := 0; s < 10; s++ {
		t27.Square(&t27)
	}

	// Step 367: t27 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c27
	t27.Mul(&t6, &t27)

	// Step 372: t27 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e0
	for s := 0; s < 5; s++ {
		t27.Square(&t27)
	}

	// Step 373: t27 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e9
	t27.Mul(&t1, &t27)

	// Step 381: t27 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e900
	for s := 0; s < 8; s++ {
		t27.Square(&t27)
	}

	// Step 382: t27 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e919
	t27.Mul(&t22, &t27)

	// Step 392: t27 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a46400
	for s := 0; s < 10; s++ {
		t27.Square(&t27)
	}

	// Step 393: t27 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f
	t27.Mul(&t24, &t27)

	// Step 400: t27 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d2320780
	for s := 0; s < 7; s++ {
		t27.Square(&t27)
	}

	// Step 401: t27 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d
	t27.Mul(&t0, &t27)

	// Step 407: t27 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c2748c81e740
	for s := 0; s < 6; s++ {
		t27.Square(&t27)
	}

	// Step 408: t27 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c2748c81e75d
	t27.Mul(&t0, &t27)

	// Step 417: t27 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903ceba00
	for s := 0; s < 9; s++ {
		t27.Square(&t27)
	}

	// Step 418: t27 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff
	t27.Mul(&t20, &t27)

	// Step 426: t27 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff00
	for s := 0; s < 8; s++ {
		t27.Square(&t27)
	}

	// Step 427: t27 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25
	t27.Mul(&t15, &t27)

	// Step 433: t27 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc940
	for s := 0; s < 6; s++ {
		t27.Square(&t27)
	}

	// Step 434: t27 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d
	t27.Mul(&t25, &t27)

	// Step 444: t27 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b400
	for s := 0; s < 10; s++ {
		t27.Square(&t27)
	}

	// Step 445: t27 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423
	t27.Mul(z, &t27)

	// Step 454: t27 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b684600
	for s := 0; s < 9; s++ {
		t27.Square(&t27)
	}

	// Step 455: t27 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b684609
	t27.Mul(&t1, &t27)

	// Step 463: t27 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b68460900
	for s := 0; s < 8; s++ {
		t27.Square(&t27)
	}

	// Step 464: t26 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d
	t26.Mul(&t26, &t27)

	// Step 473: t26 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a00
	for s := 0; s < 9; s++ {
		t26.Square(&t26)
	}

	// Step 474: t26 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a27
	t26.Mul(&t6, &t26)

	// Step 482: t26 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2700
	for s := 0; s < 8; s++ {
		t26.Square(&t26)
	}

	// Step 483: t26 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723
	t26.Mul(z, &t26)

	// Step 489: t26 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8c0
	for s := 0; s < 6; s++ {
		t26.Square(&t26)
	}

	// Step 490: t25 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed
	t25.Mul(&t25, &t26)

	// Step 499: t25 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da00
	for s := 0; s < 9; s++ {
		t25.Square(&t25)
	}

	// Step 500: t25 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25
	t25.Mul(&t15, &t25)

	// Step 504: t25 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da250
	for s := 0; s < 4; s++ {
		t25.Square(&t25)
	}

	// Step 505: t24 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25f
	t24.Mul(&t24, &t25)

	// Step 514: t24 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be00
	for s := 0; s < 9; s++ {
		t24.Square(&t24)
	}

	// Step 515: t23 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f
	t23.Mul(&t23, &t24)

	// Step 521: t23 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fc0
	for s := 0; s < 6; s++ {
		t23.Square(&t23)
	}

	// Step 522: t22 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9
	t22.Mul(&t22, &t23)

	// Step 530: t22 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd900
	for s := 0; s < 8; s++ {
		t22.Square(&t22)
	}

	// Step 531: t22 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd907
	t22.Mul(&t12, &t22)

	// Step 540: t22 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25f3fb20e00
	for s := 0; s < 9; s++ {
		t22.Square(&t22)
	}

	// Step 541: t21 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25f3fb20e3b
	t21.Mul(&t21, &t22)

	// Step 546: t21 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c760
	for s := 0; s < 5; s++ {
		t21.Square(&t21)
	}

	// Step 547: t21 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c773
	t21.Mul(&t19, &t21)

	// Step 554: t21 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25f3fb20e3b980
	for s := 0; s < 7; s++ {
		t21.Square(&t21)
	}

	// Step 555: t21 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25f3fb20e3b9a7
	t21.Mul(&t6, &t21)

	// Step 560: t21 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734e0
	for s := 0; s < 5; s++ {
		t21.Square(&t21)
	}

	// Step 561: t21 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f7
	t21.Mul(&t11, &t21)

	// Step 570: t21 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c2748c81e75d7f92da11824344e476897cfec838ee69ee00
	for s := 0; s < 9; s++ {
		t21.Square(&t21)
	}

	// Step 571: t21 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c2748c81e75d7f92da11824344e476897cfec838ee69ee39
	t21.Mul(&t8, &t21)

	// Step 577: t21 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25f3fb20e3b9a7b8e40
	for s := 0; s < 6; s++ {
		t21.Square(&t21)
	}

	// Step 578: t21 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25f3fb20e3b9a7b8e7d
	t21.Mul(&t14, &t21)

	// Step 587: t21 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfa00
	for s := 0; s < 9; s++ {
		t21.Square(&t21)
	}

	// Step 588: t20 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaff
	t20.Mul(&t20, &t21)

	// Step 590: t20 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebfc
	for s := 0; s < 2; s++ {
		t20.Square(&t20)
	}

	// Step 591: t20 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff
	t20.Mul(&t3, &t20)

	// Step 598: t20 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c2748c81e75d7f92da11824344e476897cfec838ee69ee39f5ff80
	for s := 0; s < 7; s++ {
		t20.Square(&t20)
	}

	// Step 599: t20 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c2748c81e75d7f92da11824344e476897cfec838ee69ee39f5ff97
	t20.Mul(&t11, &t20)

	// Step 605: t20 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25f3fb20e3b9a7b8e7d7fe5c0
	for s := 0; s < 6; s++ {
		t20.Square(&t20)
	}

	// Step 606: t19 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25f3fb20e3b9a7b8e7d7fe5d3
	t19.Mul(&t19, &t20)

	// Step 612: t19 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c2748c81e75d7f92da11824344e476897cfec838ee69ee39f5ff974c0
	for s := 0; s < 6; s++ {
		t19.Square(&t19)
	}

	// Step 613: t18 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c2748c81e75d7f92da11824344e476897cfec838ee69ee39f5ff974c5
	t18.Mul(&t18, &t19)

	// Step 622: t18 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a00
	for s := 0; s < 9; s++ {
		t18.Square(&t18)
	}

	// Step 623: t17 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a11
	t17.Mul(&t17, &t18)

	// Step 629: t17 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaffcba628440
	for s := 0; s < 6; s++ {
		t17.Square(&t17)
	}

	// Step 630: t16 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaffcba62845b
	t16.Mul(&t16, &t17)

	// Step 640: t16 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c00
	for s := 0; s < 10; s++ {
		t16.Square(&t16)
	}

	// Step 641: t15 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25
	t15.Mul(&t15, &t16)

	// Step 648: t15 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c2748c81e75d7f92da11824344e476897cfec838ee69ee39f5ff974c508b61280
	for s := 0; s < 7; s++ {
		t15.Square(&t15)
	}

	// Step 649: t15 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c2748c81e75d7f92da11824344e476897cfec838ee69ee39f5ff974c508b612b3
	t15.Mul(&t5, &t15)

	// Step 657: t15 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c2748c81e75d7f92da11824344e476897cfec838ee69ee39f5ff974c508b612b300
	for s := 0; s < 8; s++ {
		t15.Square(&t15)
	}

	// Step 658: t14 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c2748c81e75d7f92da11824344e476897cfec838ee69ee39f5ff974c508b612b33d
	t14.Mul(&t14, &t15)

	// Step 665: t14 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaffcba62845b09599e80
	for s := 0; s < 7; s++ {
		t14.Square(&t14)
	}

	// Step 666: t14 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaffcba62845b09599ea3
	t14.Mul(z, &t14)

	// Step 669: t14 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25f3fb20e3b9a7b8e7d7fe5d31422d84accf518
	for s := 0; s < 3; s++ {
		t14.Square(&t14)
	}

	// Step 670: t14 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25f3fb20e3b9a7b8e7d7fe5d31422d84accf51f
	t14.Mul(&t12, &t14)

	// Step 680: t14 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c2748c81e75d7f92da11824344e476897cfec838ee69ee39f5ff974c508b612b33d47c00
	for s := 0; s < 10; s++ {
		t14.Square(&t14)
	}

	// Step 681: t13 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c2748c81e75d7f92da11824344e476897cfec838ee69ee39f5ff974c508b612b33d47c0b
	t13.Mul(&t13, &t14)

	// Step 692: t13 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaffcba62845b09599ea3e05800
	for s := 0; s < 11; s++ {
		t13.Square(&t13)
	}

	// Step 693: t13 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaffcba62845b09599ea3e05833
	t13.Mul(&t5, &t13)

	// Step 696: t13 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25f3fb20e3b9a7b8e7d7fe5d31422d84accf51f02c198
	for s := 0; s < 3; s++ {
		t13.Square(&t13)
	}

	// Step 697: t12 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25f3fb20e3b9a7b8e7d7fe5d31422d84accf51f02c19f
	t12.Mul(&t12, &t13)

	// Step 706: t12 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaffcba62845b09599ea3e05833e00
	for s := 0; s < 9; s++ {
		t12.Square(&t12)
	}

	// Step 707: t12 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaffcba62845b09599ea3e05833e2b
	t12.Mul(&t10, &t12)

	// Step 712: t12 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c2748c81e75d7f92da11824344e476897cfec838ee69ee39f5ff974c508b612b33d47c0b067c560
	for s := 0; s < 5; s++ {
		t12.Square(&t12)
	}

	// Step 713: t11 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c2748c81e75d7f92da11824344e476897cfec838ee69ee39f5ff974c508b612b33d47c0b067c577
	t11.Mul(&t11, &t12)

	// Step 720: t11 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaffcba62845b09599ea3e05833e2bb80
	for s := 0; s < 7; s++ {
		t11.Square(&t11)
	}

	// Step 721: t10 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaffcba62845b09599ea3e05833e2bbab
	t10.Mul(&t10, &t11)

	// Step 723: t10 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeac
	for s := 0; s < 2; s++ {
		t10.Square(&t10)
	}

	// Step 724: t10 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf
	t10.Mul(&t3, &t10)

	// Step 734: t10 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaffcba62845b09599ea3e05833e2bbabc00
	for s := 0; s < 10; s++ {
		t10.Square(&t10)
	}

	// Step 735: t10 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaffcba62845b09599ea3e05833e2bbabc29
	t10.Mul(&t7, &t10)

	// Step 745: t10 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a400
	for s := 0; s < 10; s++ {
		t10.Square(&t10)
	}

	// Step 746: t9 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437
	t9.Mul(&t9, &t10)

	// Step 752: t9 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaffcba62845b09599ea3e05833e2bbabc290dc0
	for s := 0; s < 6; s++ {
		t9.Square(&t9)
	}

	// Step 753: t8 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaffcba62845b09599ea3e05833e2bbabc290df9
	t8.Mul(&t8, &t9)

	// Step 759: t8 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e40
	for s := 0; s < 6; s++ {
		t8.Square(&t8)
	}

	// Step 760: t7 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e69
	t7.Mul(&t7, &t8)

	// Step 769: t7 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25f3fb20e3b9a7b8e7d7fe5d31422d84accf51f02c19f15dd5e1486fcd200
	for s := 0; s < 9; s++ {
		t7.Square(&t7)
	}

	// Step 770: t6 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25f3fb20e3b9a7b8e7d7fe5d31422d84accf51f02c19f15dd5e1486fcd227
	t6.Mul(&t6, &t7)

	// Step 776: t6 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c2748c81e75d7f92da11824344e476897cfec838ee69ee39f5ff974c508b612b33d47c0b067c577578521bf3489c0
	for s := 0; s < 6; s++ {
		t6.Square(&t6)
	}

	// Step 777: t5 = x^0x9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c2748c81e75d7f92da11824344e476897cfec838ee69ee39f5ff974c508b612b33d47c0b067c577578521bf3489f3
	t5.Mul(&t5, &t6)

	// Step 784: t5 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaffcba62845b09599ea3e05833e2bbabc290df9a44f980
	for s := 0; s < 7; s++ {
		t5.Square(&t5)
	}

	// Step 785: t4 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaffcba62845b09599ea3e05833e2bbabc290df9a44f9a1
	t4.Mul(&t4, &t5)

	// Step 787: t4 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e6913e684
	for s := 0; s < 2; s++ {
		t4.Square(&t4)
	}

	// Step 788: t3 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e6913e687
	t3.Mul(&t3, &t4)

	// Step 809: t3 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25f3fb20e3b9a7b8e7d7fe5d31422d84accf51f02c19f15dd5e1486fcd227cd0e00000
	for s := 0; s < 21; s++ {
		t3.Square(&t3)
	}

	// Step 810: t3 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25f3fb20e3b9a7b8e7d7fe5d31422d84accf51f02c19f15dd5e1486fcd227cd0e00001
	t3.Mul(x, &t3)

	// Step 821: t3 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e6913e68700000800
	for s := 0; s < 11; s++ {
		t3.Square(&t3)
	}

	// Step 822: t2 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e6913e6870000082f
	t2.Mul(&t2, &t3)

	// Step 827: t2 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25f3fb20e3b9a7b8e7d7fe5d31422d84accf51f02c19f15dd5e1486fcd227cd0e0000105e0
	for s := 0; s < 5; s++ {
		t2.Square(&t2)
	}

	// Step 828: t1 = x^0x245d049f7079c15a30f928009f5fe7d724c30d503a28d10a504ebdf010f7c82e0f74c71cb09d232079d75fe4b6846090d1391da25f3fb20e3b9a7b8e7d7fe5d31422d84accf51f02c19f15dd5e1486fcd227cd0e0000105e9
	t1.Mul(&t1, &t2)

	// Step 835: t1 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e6913e6870000082f480
	for s := 0; s < 7; s++ {
		t1.Square(&t1)
	}

	// Step 836: t0 = x^0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e6913e6870000082f49d
	t0.Mul(&t0, &t1)

	// Step 882: t0 = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaffcba62845b09599ea3e05833e2bbabc290df9a44f9a1c000020bd27400000000000
	for s := 0; s < 46; s++ {
		t0.Square(&t0)
	}

	// Step 883: z = x^0x48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaffcba62845b09599ea3e05833e2bbabc290df9a44f9a1c000020bd27400000000023
	z.Mul(z, &t0)

	return z
}

// Exp z = x^exponent mod q
func (z *Element) Exp(x Element, exponent *big.Int) *Element {
	var bZero big.Int
	if exponent.Cmp(&bZero) == 0 {
		return z.SetOne()
	}

	z.Set(&x)

	for i := exponent.BitLen() - 2; i >= 0; i-- {
		z.Square(z)
		if exponent.Bit(i) == 1 {
			z.Mul(z, &x)
		}
	}

	return z
}

// ToMont converts z to Montgomery form
// sets and returns z = z * r^2
func (z *Element) ToMont() *Element {
	return z.Mul(z, &rSquare)
}

// ToRegular returns z in regular form (doesn't mutate z)
func (z Element) ToRegular() Element {
	return *z.FromMont()
}

// String returns the string form of an Element in Montgomery form
func (z *Element) String() string {
	zz := *z
	zz.FromMont()
	if zz.IsUint64() {
		return strconv.FormatUint(zz[0], 10)
	} else {
		var zzNeg Element
		zzNeg.Neg(z)
		zzNeg.FromMont()
		if zzNeg.IsUint64() {
			return "-" + strconv.FormatUint(zzNeg[0], 10)
		}
	}
	vv := bigIntPool.Get().(*big.Int)
	defer bigIntPool.Put(vv)
	return zz.ToBigInt(vv).String()
}

// ToBigInt returns z as a big.Int in Montgomery form
func (z *Element) ToBigInt(res *big.Int) *big.Int {
	var b [Limbs * 8]byte
	binary.BigEndian.PutUint64(b[88:96], z[0])
	binary.BigEndian.PutUint64(b[80:88], z[1])
	binary.BigEndian.PutUint64(b[72:80], z[2])
	binary.BigEndian.PutUint64(b[64:72], z[3])
	binary.BigEndian.PutUint64(b[56:64], z[4])
	binary.BigEndian.PutUint64(b[48:56], z[5])
	binary.BigEndian.PutUint64(b[40:48], z[6])
	binary.BigEndian.PutUint64(b[32:40], z[7])
	binary.BigEndian.PutUint64(b[24:32], z[8])
	binary.BigEndian.PutUint64(b[16:24], z[9])
	binary.BigEndian.PutUint64(b[8:16], z[10])
	binary.BigEndian.PutUint64(b[0:8], z[11])

	return res.SetBytes(b[:])
}

// ToBigIntRegular returns z as a big.Int in regular form
func (z Element) ToBigIntRegular(res *big.Int) *big.Int {
	z.FromMont()
	return z.ToBigInt(res)
}

// Bytes returns the regular (non montgomery) value
// of z as a big-endian byte array.
func (z *Element) Bytes() (res [Limbs * 8]byte) {
	_z := z.ToRegular()
	binary.BigEndian.PutUint64(res[88:96], _z[0])
	binary.BigEndian.PutUint64(res[80:88], _z[1])
	binary.BigEndian.PutUint64(res[72:80], _z[2])
	binary.BigEndian.PutUint64(res[64:72], _z[3])
	binary.BigEndian.PutUint64(res[56:64], _z[4])
	binary.BigEndian.PutUint64(res[48:56], _z[5])
	binary.BigEndian.PutUint64(res[40:48], _z[6])
	binary.BigEndian.PutUint64(res[32:40], _z[7])
	binary.BigEndian.PutUint64(res[24:32], _z[8])
	binary.BigEndian.PutUint64(res[16:24], _z[9])
	binary.BigEndian.PutUint64(res[8:16], _z[10])
	binary.BigEndian.PutUint64(res[0:8], _z[11])

	return
}

// Marshal returns the regular (non montgomery) value
// of z as a big-endian byte slice.
func (z *Element) Marshal() []byte {
	b := z.Bytes()
	return b[:]
}

// SetBytes interprets e as the bytes of a big-endian unsigned integer,
// sets z to that value (in Montgomery form), and returns z.
func (z *Element) SetBytes(e []byte) *Element {
	// get a big int from our pool
	vv := bigIntPool.Get().(*big.Int)
	vv.SetBytes(e)

	// set big int
	z.SetBigInt(vv)

	// put temporary object back in pool
	bigIntPool.Put(vv)

	return z
}

// SetBigInt sets z to v (regular form) and returns z in Montgomery form
func (z *Element) SetBigInt(v *big.Int) *Element {
	z.SetZero()

	var zero big.Int

	// fast path
	c := v.Cmp(&_modulus)
	if c == 0 {
		// v == 0
		return z
	} else if c != 1 && v.Cmp(&zero) != -1 {
		// 0 < v < q
		return z.setBigInt(v)
	}

	// get temporary big int from the pool
	vv := bigIntPool.Get().(*big.Int)

	// copy input + modular reduction
	vv.Set(v)
	vv.Mod(v, &_modulus)

	// set big int byte value
	z.setBigInt(vv)

	// release object into pool
	bigIntPool.Put(vv)
	return z
}

// setBigInt assumes 0 <= v < q
func (z *Element) setBigInt(v *big.Int) *Element {
	vBits := v.Bits()

	if bits.UintSize == 64 {
		for i := 0; i < len(vBits); i++ {
			z[i] = uint64(vBits[i])
		}
	} else {
		for i := 0; i < len(vBits); i++ {
			if i%2 == 0 {
				z[i/2] = uint64(vBits[i])
			} else {
				z[i/2] |= uint64(vBits[i]) << 32
			}
		}
	}

	return z.ToMont()
}

// SetString creates a big.Int with s (in base 10) and calls SetBigInt on z
func (z *Element) SetString(s string) *Element {
	// get temporary big int from the pool
	vv := bigIntPool.Get().(*big.Int)

	if _, ok := vv.SetString(s, 10); !ok {
		panic("Element.SetString failed -> can't parse number in base10 into a big.Int")
	}
	z.SetBigInt(vv)

	// release object into pool
	bigIntPool.Put(vv)

	return z
}

var (
	_bLegendreExponentElement *big.Int
	_bSqrtExponentElement     *big.Int
)

func init() {
	_bLegendreExponentElement, _ = new(big.Int).SetString("9174127dc1e70568c3e4a0027d7f9f5c930c3540e8a34429413af7c043df20b83dd31c72c2748c81e75d7f92da11824344e476897cfec838ee69ee39f5ff974c508b612b33d47c0b067c577578521bf3489f34380000417a4e800000000045", 16)
	const sqrtExponentElement = "48ba093ee0f382b461f250013ebfcfae49861aa07451a214a09d7be021ef905c1ee98e39613a4640f3aebfc96d08c121a2723b44be7f641c7734f71cfaffcba62845b09599ea3e05833e2bbabc290df9a44f9a1c000020bd27400000000023"
	_bSqrtExponentElement, _ = new(big.Int).SetString(sqrtExponentElement, 16)
}

// Legendre returns the Legendre symbol of z (either +1, -1, or 0.)
func (z *Element) Legendre() int {
	var l Element
	// z^((q-1)/2)
	l.Exp(*z, _bLegendreExponentElement)

	if l.IsZero() {
		return 0
	}

	// if l == 1
	if (l[11] == 23071597697427581) && (l[10] == 15539704305423854047) && (l[9] == 5009280847225881135) && (l[8] == 8887388221587179644) && (l[7] == 2545351818702954755) && (l[6] == 12055474021000362245) && (l[5] == 13899911246788437003) && (l[4] == 17071399330169272331) && (l[3] == 15738672438262922740) && (l[2] == 11428286765660613342) && (l[1] == 6509995272855063783) && (l[0] == 144959613005956565) {
		return 1
	}
	return -1
}

// Sqrt z = √x mod q
// if the square root doesn't exist (x is not a square mod q)
// Sqrt leaves z unchanged and returns nil
func (z *Element) Sqrt(x *Element) *Element {
	// q ≡ 3 (mod 4)
	// using  z ≡ ± x^((p+1)/4) (mod q)
	var y, square Element
	y.expBySqrtExp(x)
	// y.Exp(*x, _bSqrtExponentElement)
	// as we didn't compute the legendre symbol, ensure we found y such that y * y = x
	square.Square(&y)
	if square.Equal(x) {
		return z.Set(&y)
	}
	return nil
}

// Inverse z = x^-1 mod q
// Algorithm 16 in "Efficient Software-Implementation of Finite Fields with Applications to Cryptography"
// if x == 0, sets and returns z = x
func (z *Element) Inverse(x *Element) *Element {
	if x.IsZero() {
		z.SetZero()
		return z
	}

	// initialize u = q
	var u = Element{
		17626244516597989515,
		16614129118623039618,
		1588918198704579639,
		10998096788944562424,
		8204665564953313070,
		9694500593442880912,
		274362232328168196,
		8105254717682411801,
		5945444129596489281,
		13341377791855249032,
		15098257552581525310,
		81882988782276106,
	}

	// initialize s = r^2
	var s = Element{
		14305184132582319705,
		8868935336694416555,
		9196887162930508889,
		15486798265448570248,
		5402985275949444416,
		10893197322525159598,
		3204916688966998390,
		12417238192559061753,
		12426306557607898622,
		1305582522441154384,
		10311846026977660324,
		48736111365249031,
	}

	// r = 0
	r := Element{}

	v := *x

	var carry, borrow uint64
	var bigger bool

	for {
		for v[0]&1 == 0 {

			// v = v >> 1

			v[0] = v[0]>>1 | v[1]<<63
			v[1] = v[1]>>1 | v[2]<<63
			v[2] = v[2]>>1 | v[3]<<63
			v[3] = v[3]>>1 | v[4]<<63
			v[4] = v[4]>>1 | v[5]<<63
			v[5] = v[5]>>1 | v[6]<<63
			v[6] = v[6]>>1 | v[7]<<63
			v[7] = v[7]>>1 | v[8]<<63
			v[8] = v[8]>>1 | v[9]<<63
			v[9] = v[9]>>1 | v[10]<<63
			v[10] = v[10]>>1 | v[11]<<63
			v[11] >>= 1

			if s[0]&1 == 1 {

				// s = s + q
				s[0], carry = bits.Add64(s[0], 17626244516597989515, 0)
				s[1], carry = bits.Add64(s[1], 16614129118623039618, carry)
				s[2], carry = bits.Add64(s[2], 1588918198704579639, carry)
				s[3], carry = bits.Add64(s[3], 10998096788944562424, carry)
				s[4], carry = bits.Add64(s[4], 8204665564953313070, carry)
				s[5], carry = bits.Add64(s[5], 9694500593442880912, carry)
				s[6], carry = bits.Add64(s[6], 274362232328168196, carry)
				s[7], carry = bits.Add64(s[7], 8105254717682411801, carry)
				s[8], carry = bits.Add64(s[8], 5945444129596489281, carry)
				s[9], carry = bits.Add64(s[9], 13341377791855249032, carry)
				s[10], carry = bits.Add64(s[10], 15098257552581525310, carry)
				s[11], _ = bits.Add64(s[11], 81882988782276106, carry)

			}

			// s = s >> 1

			s[0] = s[0]>>1 | s[1]<<63
			s[1] = s[1]>>1 | s[2]<<63
			s[2] = s[2]>>1 | s[3]<<63
			s[3] = s[3]>>1 | s[4]<<63
			s[4] = s[4]>>1 | s[5]<<63
			s[5] = s[5]>>1 | s[6]<<63
			s[6] = s[6]>>1 | s[7]<<63
			s[7] = s[7]>>1 | s[8]<<63
			s[8] = s[8]>>1 | s[9]<<63
			s[9] = s[9]>>1 | s[10]<<63
			s[10] = s[10]>>1 | s[11]<<63
			s[11] >>= 1

		}
		for u[0]&1 == 0 {

			// u = u >> 1

			u[0] = u[0]>>1 | u[1]<<63
			u[1] = u[1]>>1 | u[2]<<63
			u[2] = u[2]>>1 | u[3]<<63
			u[3] = u[3]>>1 | u[4]<<63
			u[4] = u[4]>>1 | u[5]<<63
			u[5] = u[5]>>1 | u[6]<<63
			u[6] = u[6]>>1 | u[7]<<63
			u[7] = u[7]>>1 | u[8]<<63
			u[8] = u[8]>>1 | u[9]<<63
			u[9] = u[9]>>1 | u[10]<<63
			u[10] = u[10]>>1 | u[11]<<63
			u[11] >>= 1

			if r[0]&1 == 1 {

				// r = r + q
				r[0], carry = bits.Add64(r[0], 17626244516597989515, 0)
				r[1], carry = bits.Add64(r[1], 16614129118623039618, carry)
				r[2], carry = bits.Add64(r[2], 1588918198704579639, carry)
				r[3], carry = bits.Add64(r[3], 10998096788944562424, carry)
				r[4], carry = bits.Add64(r[4], 8204665564953313070, carry)
				r[5], carry = bits.Add64(r[5], 9694500593442880912, carry)
				r[6], carry = bits.Add64(r[6], 274362232328168196, carry)
				r[7], carry = bits.Add64(r[7], 8105254717682411801, carry)
				r[8], carry = bits.Add64(r[8], 5945444129596489281, carry)
				r[9], carry = bits.Add64(r[9], 13341377791855249032, carry)
				r[10], carry = bits.Add64(r[10], 15098257552581525310, carry)
				r[11], _ = bits.Add64(r[11], 81882988782276106, carry)

			}

			// r = r >> 1

			r[0] = r[0]>>1 | r[1]<<63
			r[1] = r[1]>>1 | r[2]<<63
			r[2] = r[2]>>1 | r[3]<<63
			r[3] = r[3]>>1 | r[4]<<63
			r[4] = r[4]>>1 | r[5]<<63
			r[5] = r[5]>>1 | r[6]<<63
			r[6] = r[6]>>1 | r[7]<<63
			r[7] = r[7]>>1 | r[8]<<63
			r[8] = r[8]>>1 | r[9]<<63
			r[9] = r[9]>>1 | r[10]<<63
			r[10] = r[10]>>1 | r[11]<<63
			r[11] >>= 1

		}

		// v >= u
		bigger = !(v[11] < u[11] || (v[11] == u[11] && (v[10] < u[10] || (v[10] == u[10] && (v[9] < u[9] || (v[9] == u[9] && (v[8] < u[8] || (v[8] == u[8] && (v[7] < u[7] || (v[7] == u[7] && (v[6] < u[6] || (v[6] == u[6] && (v[5] < u[5] || (v[5] == u[5] && (v[4] < u[4] || (v[4] == u[4] && (v[3] < u[3] || (v[3] == u[3] && (v[2] < u[2] || (v[2] == u[2] && (v[1] < u[1] || (v[1] == u[1] && (v[0] < u[0])))))))))))))))))))))))

		if bigger {

			// v = v - u
			v[0], borrow = bits.Sub64(v[0], u[0], 0)
			v[1], borrow = bits.Sub64(v[1], u[1], borrow)
			v[2], borrow = bits.Sub64(v[2], u[2], borrow)
			v[3], borrow = bits.Sub64(v[3], u[3], borrow)
			v[4], borrow = bits.Sub64(v[4], u[4], borrow)
			v[5], borrow = bits.Sub64(v[5], u[5], borrow)
			v[6], borrow = bits.Sub64(v[6], u[6], borrow)
			v[7], borrow = bits.Sub64(v[7], u[7], borrow)
			v[8], borrow = bits.Sub64(v[8], u[8], borrow)
			v[9], borrow = bits.Sub64(v[9], u[9], borrow)
			v[10], borrow = bits.Sub64(v[10], u[10], borrow)
			v[11], _ = bits.Sub64(v[11], u[11], borrow)

			// s = s - r
			s[0], borrow = bits.Sub64(s[0], r[0], 0)
			s[1], borrow = bits.Sub64(s[1], r[1], borrow)
			s[2], borrow = bits.Sub64(s[2], r[2], borrow)
			s[3], borrow = bits.Sub64(s[3], r[3], borrow)
			s[4], borrow = bits.Sub64(s[4], r[4], borrow)
			s[5], borrow = bits.Sub64(s[5], r[5], borrow)
			s[6], borrow = bits.Sub64(s[6], r[6], borrow)
			s[7], borrow = bits.Sub64(s[7], r[7], borrow)
			s[8], borrow = bits.Sub64(s[8], r[8], borrow)
			s[9], borrow = bits.Sub64(s[9], r[9], borrow)
			s[10], borrow = bits.Sub64(s[10], r[10], borrow)
			s[11], borrow = bits.Sub64(s[11], r[11], borrow)

			if borrow == 1 {

				// s = s + q
				s[0], carry = bits.Add64(s[0], 17626244516597989515, 0)
				s[1], carry = bits.Add64(s[1], 16614129118623039618, carry)
				s[2], carry = bits.Add64(s[2], 1588918198704579639, carry)
				s[3], carry = bits.Add64(s[3], 10998096788944562424, carry)
				s[4], carry = bits.Add64(s[4], 8204665564953313070, carry)
				s[5], carry = bits.Add64(s[5], 9694500593442880912, carry)
				s[6], carry = bits.Add64(s[6], 274362232328168196, carry)
				s[7], carry = bits.Add64(s[7], 8105254717682411801, carry)
				s[8], carry = bits.Add64(s[8], 5945444129596489281, carry)
				s[9], carry = bits.Add64(s[9], 13341377791855249032, carry)
				s[10], carry = bits.Add64(s[10], 15098257552581525310, carry)
				s[11], _ = bits.Add64(s[11], 81882988782276106, carry)

			}
		} else {

			// u = u - v
			u[0], borrow = bits.Sub64(u[0], v[0], 0)
			u[1], borrow = bits.Sub64(u[1], v[1], borrow)
			u[2], borrow = bits.Sub64(u[2], v[2], borrow)
			u[3], borrow = bits.Sub64(u[3], v[3], borrow)
			u[4], borrow = bits.Sub64(u[4], v[4], borrow)
			u[5], borrow = bits.Sub64(u[5], v[5], borrow)
			u[6], borrow = bits.Sub64(u[6], v[6], borrow)
			u[7], borrow = bits.Sub64(u[7], v[7], borrow)
			u[8], borrow = bits.Sub64(u[8], v[8], borrow)
			u[9], borrow = bits.Sub64(u[9], v[9], borrow)
			u[10], borrow = bits.Sub64(u[10], v[10], borrow)
			u[11], _ = bits.Sub64(u[11], v[11], borrow)

			// r = r - s
			r[0], borrow = bits.Sub64(r[0], s[0], 0)
			r[1], borrow = bits.Sub64(r[1], s[1], borrow)
			r[2], borrow = bits.Sub64(r[2], s[2], borrow)
			r[3], borrow = bits.Sub64(r[3], s[3], borrow)
			r[4], borrow = bits.Sub64(r[4], s[4], borrow)
			r[5], borrow = bits.Sub64(r[5], s[5], borrow)
			r[6], borrow = bits.Sub64(r[6], s[6], borrow)
			r[7], borrow = bits.Sub64(r[7], s[7], borrow)
			r[8], borrow = bits.Sub64(r[8], s[8], borrow)
			r[9], borrow = bits.Sub64(r[9], s[9], borrow)
			r[10], borrow = bits.Sub64(r[10], s[10], borrow)
			r[11], borrow = bits.Sub64(r[11], s[11], borrow)

			if borrow == 1 {

				// r = r + q
				r[0], carry = bits.Add64(r[0], 17626244516597989515, 0)
				r[1], carry = bits.Add64(r[1], 16614129118623039618, carry)
				r[2], carry = bits.Add64(r[2], 1588918198704579639, carry)
				r[3], carry = bits.Add64(r[3], 10998096788944562424, carry)
				r[4], carry = bits.Add64(r[4], 8204665564953313070, carry)
				r[5], carry = bits.Add64(r[5], 9694500593442880912, carry)
				r[6], carry = bits.Add64(r[6], 274362232328168196, carry)
				r[7], carry = bits.Add64(r[7], 8105254717682411801, carry)
				r[8], carry = bits.Add64(r[8], 5945444129596489281, carry)
				r[9], carry = bits.Add64(r[9], 13341377791855249032, carry)
				r[10], carry = bits.Add64(r[10], 15098257552581525310, carry)
				r[11], _ = bits.Add64(r[11], 81882988782276106, carry)

			}
		}
		if (u[0] == 1) && (u[11]|u[10]|u[9]|u[8]|u[7]|u[6]|u[5]|u[4]|u[3]|u[2]|u[1]) == 0 {
			z.Set(&r)
			return z
		}
		if (v[0] == 1) && (v[11]|v[10]|v[9]|v[8]|v[7]|v[6]|v[5]|v[4]|v[3]|v[2]|v[1]) == 0 {
			z.Set(&s)
			return z
		}
	}

}
